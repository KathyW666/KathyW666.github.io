<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于 怪诞行为学 的一些想法]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%85%B3%E4%BA%8E-%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.11.08 update9月份在实验室书架上发现了这本《怪诞行为学》，我自己是对心理学有毫无来由的喜爱，对不正常事件也充满了好奇，估计挺适合找bug的。一开始每天去书架那里看，后来情到深处就拿到自己那里看了，打算看完在放回去。 Dan Ariley 这本书2010年出版的，到现在都快10年了。不过其中的实验和例子非常有趣不乏味。 首先Dan描述了一场飞来横祸使其对行为经济学的兴趣大增的例子。Dan经历过一场镁光灯爆炸，全身70%的皮肤遭受三度烧伤。之后他引出了一个exceptional的问题：怎么撕绷带/膏药/创可贴一类的东西？ Dan恢复时每天要浸在消毒液里(?这里我很疑惑啊，想到了木乃伊)，刮掉坏死的皮肤，再包扎起来。每次换药都会牵扯到尚未完全愈合的伤口，必然非常疼痛。可以设想一下撕一块贴在身上一天的狗皮膏药。他的护士选择：快速用力扯，刷的一下。这实在太疼了，尤其对如同木乃伊一般烧伤患者。经过多次痛苦的实践，Dan觉得是时候和医生建议：低疼痛的密度的慢速撕扯 要比刷的一下更能使患者接受。不过他忘记考虑了动作发出者的心里，即病人痛苦的表现给护士本人带来的心理折磨，也是导致护士选择速战速决的原因之一。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>怪诞行为学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本文参考keyvanakbary,ForeseeMark,zerods-seu的成果 8 puzzle Dynamic Median RandomizedPQ Taxicab 1、8 puzzle类似于华容道，A*算法的应用,对于Dijstra来说省略无用的路径，更加高效。 由两个类构成 Board() &amp; Soler()， 相当于以版做单位， 移动之后的状态作为新的Board，存储于优先队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.util.LinkedList;/** Week 4 - 8 puzzle * Reference: keyvanakbary * Url: https://github.com/keyvanakbary/princeton-algorithms/blob/master/week-4-8-puzzle */public class Board &#123; private static int[][] blocks; public Board(int[][] blocks) &#123; //immutable data type this.blocks = copy(blocks); &#125; private int[][] copy(int[][] blocks) &#123; int[][] copy = new int[blocks.length][blocks.length]; for (int row = 0; row &lt; blocks.length; row++) for (int col = 0; col &lt; blocks.length; col++) copy[row][col] = blocks[row][col]; return copy; &#125; public int dimension() &#123; return blocks.length; &#125; /** * Number of blocks out of place * @return count */ public int hamming() &#123; int count = 0; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) count++; &#125; &#125; return count; &#125; /** * sum of Manhattan distances between blocks and goal * @return sum */ public int manhattan() &#123; int sum = 0; int r, c; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; r = (blocks[row][col] - 1) / dimension(); c = (blocks[row][col] - 1) % dimension(); sum += (Math.abs(row - r) + Math.abs(col - c)); &#125; &#125; return sum; &#125; public boolean isGoal() &#123; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) return false; &#125; &#125; return true; &#125; /** * Judging whether a Board is solvable with a twin Board * @return twin Board */ public Board twin() &#123; int[][] copy = copy(blocks); int rr = 0; if (blocks[rr][0] * blocks[rr][1] == 0) rr = 1; copy[rr][0] = blocks[rr][1]; copy[rr][1] = blocks[rr][0]; return new Board(copy); &#125; public boolean equals(Object that) &#123; // instanceof 指出对象是否是特定类的一个实例 if (this == that) return true; if (that == null || !(that instanceof Board) || ((Board) that).blocks.length != blocks.length) return false; for (int row = 0; row &lt; dimension(); row++) for (int col = 0; col &lt; dimension(); col++) if (((Board) that).blocks[row][col] != blocks[row][col]) return false; return true; &#125; /** * Add the available neighbors to the priority queue * @return an Iterable LinkedList&lt;Board&gt; */ public Iterable&lt;Board&gt; neighbors() &#123; LinkedList&lt;Board&gt; neighbors = new LinkedList&lt;&gt;(); int sR= SpaceLocation()[0]; int sC = SpaceLocation()[1]; if (sR &gt; 0) neighbors.add(new Board(swap(sR, sC, sR - 1, sC))); if (sR &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR + 1, sC))); if (sC &gt; 0) neighbors.add(new Board(swap(sR, sC, sR, sC - 1))); if (sC &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR, sC + 1))); return neighbors; &#125; /** * Swap two blocks * @param r1 row of block1 * @param c1 col of block1 * @param r2 row of block2 * @param c2 col of block2 * @return the swapped array */ private int[][] swap(int r1, int c1, int r2, int c2) &#123; int[][] sblocks = copy(blocks); int tmp = sblocks[r1][c1]; sblocks[r1][c1] = sblocks[r2][c2]; sblocks[r2][c2] = tmp; return sblocks; &#125; /** * @return an array with the location of Space */ private int[] SpaceLocation() &#123; int flag = 0; int[] SL = new int[2]; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) &#123; SL[0] = row; SL[1] = col; flag = 1; break; &#125; &#125; if (flag != 0) break; &#125; return SL; &#125; public String toString() &#123; StringBuilder s = new StringBuilder(); s.append(dimension() + "\n"); for (int i = 0; i &lt; dimension(); i++) &#123; for (int j = 0; j &lt; dimension(); j++) &#123; s.append(String.format("%2d ", blocks[i][j])); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 2、Dynamic Medianjjjoo,找到一组数的中位数 （1）增加一个元素，时间O(log(n))时间 （2）返回当前元素集合的中位数，O(n)时间。 （3）删除中位数，log(n)时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import edu.princeton.cs.algs4.MaxPQ;import edu.princeton.cs.algs4.MinPQ;/** ******************************************************************************** * Week4: Interview Questions: Priority Queues * Dynamic Median * 使用两个堆维护中位数，这里临界条件"="在MaxPQ上 * judge() 存在边界bug * Reference：1 ForeseeMark https://blog.csdn.net/wr339988/article/details/55813202 * 2 zerods-seu https://blog.csdn.net/zerodshei/article/details/54346425 ***********************************************************************************/public class DynamicMedian &#123; private MinPQ minPQ = new MinPQ(); private MaxPQ maxPQ = new MaxPQ(); public int num = 0; public DynamicMedian() &#123;&#125; public void insert(int n) &#123; if (num == 0) &#123; minPQ.insert(n); num++; return; &#125; if (num == 1) &#123; maxPQ.insert(n); num++; return; &#125; if (n &lt;= (int) maxPQ.max()) maxPQ.insert(n); else minPQ.insert(n); judge(); num++; &#125; public int nums() &#123; return num; &#125; public void delMid() &#123; judge(); maxPQ.delMax(); num--; &#125; /** **************************************************************************** * 2018-09-30 * 判断: 若两个堆的元素个数&gt;1, 则将大堆的顶部元素放入小堆中重排 * 【2】中直接以大堆的顶部元素作为中位数，可能会出现边界情况：[2,3,1] * delMid() 返回 3 ------- BUG * * minPQ maxPQ * 2 3 * 1 * 2018-10-09 update * +立flag 解决边界调节的bug *******************************************************************************/ private void judge() &#123; if (num == 0) throw new NullPointerException(); boolean flag = false; int subVal = maxPQ.size() - minPQ.size(); while (Math.abs(subVal) &gt;= 1) &#123; if (subVal == 1 &amp;&amp; flag) break; if (subVal &lt; -1) maxPQ.insert(minPQ.delMin()); if (subVal == -1) &#123; maxPQ.insert(minPQ.delMin()); flag = true; &#125; if (subVal &gt; 1) minPQ.insert(maxPQ.delMax()); subVal = maxPQ.size() - minPQ.size(); &#125; &#125; public int queryMid() &#123; return (int) maxPQ.max(); &#125; // Test public static void main(String[] args) &#123; DynamicMedian dm = new DynamicMedian(); dm.insert(4); dm.insert(3); dm.insert(5); System.out.println(dm.queryMid()); dm.delMid(); dm.insert(10); dm.insert(2); System.out.println(dm.queryMid()); &#125;&#125; 3、RandomizedPQ具体和课程中给出的优先队列并无二致，加入delRandom()随机删除一个元素，和删除堆顶元素类似 1234567891011public Key delRandom() &#123; if (isEmpty()) throw new NoSuchElementException("Priority queue underflow"); int rdNum = StdRandom.uniform(1,n); Key rd = pq[rdNum]; exch(rdNum, n--); sink(rdNum); pq[n+1] = null; // to avoid loiterig and help with garbage collection if ((n &gt; 0) &amp;&amp; (n == (pq.length - 1) / 4)) resize(pq.length / 2); assert isMinHeap(); return rd; &#125; 4、TaxicabTaxicab numbers. A taxicab number is an integer that can be expressed as the sum of two cubes of integers in two different ways: a3+b3=c3+d3. For example, 1729=93+103=13+123. Design an algorithm to find all taxicab numbers with a, b, c, and d less than n.Version 1: Use time proportional to n2logn and space proportional to n2.Version 2: Use time proportional to n2logn and space proportional to n. zerods-seu的文章中写到：先计算出所有小于n1/3 +1的整数的3次方，放在数组cube[]里面，然后循环，从余下项目中二分法查找(obj-num2), 如果找到了count++，最后如果count等于2, 那么既满足要求。复杂度是$n4/3logn的，空间复杂度是n1/3+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import edu.princeton.cs.algs4.StdOut;import java.util.*;public class Taxicab &#123; public boolean find(int a) &#123; int count = 0; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) count++; if (count &gt; 2) return true; &#125; return false; &#125; public int[] Numb(int a) &#123; int count = 0; int[] nums = new int[4]; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) &#123; count++; if (count == 1) &#123; nums[0] = i; nums[1] = a1; &#125; if (count == 2) &#123; nums[2] = i; nums[3] = a1; &#125; &#125; if (count &gt; 2) return nums; &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; Taxicab tc = new Taxicab(); Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int i = 0, k = 1; while (i &lt; n) &#123; if (tc.find(k)) &#123; i++; System.out.println(i + " th ramanujan number is " + k); System.out.println(tc.Numb(k)[0] + " " + tc.Numb(k)[1] + " &amp; " + tc.Numb(k)[2] + " " + tc.Numb(k)[3]); &#125; k++; &#125; scan.close(); &#125;&#125;]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Capacity of 3D Scale Free Wireless Network]]></title>
    <url>%2F2018%2F09%2F10%2FCapacity-of-3D-Scale-Free-Wireless-Network%2F</url>
    <content type="text"><![CDATA[还记得大四做毕设的时候，看完了20多篇文献。想着这个二维的栅格模型扩展到三维难道不是很容易吗。一个呆在寝室的下午，坐在桌前，面对着一个魔方，想了一会之后豁然开朗。就有了这个 veeery tiny 的小idea。Poster版面也是亲手设计的，这个小文章真的算是亲儿子了。]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counting inversions（逆序对计数问题）]]></title>
    <url>%2F2018%2F07%2F26%2FCounting%20inversions%EF%BC%88%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文参考淡然坊,evasean的blog 首先想到的是，在插入排序中逆序对的个数就是元素交换的次数。这种特性存在于稳定的排序算法中（归并，冒泡，插入），非稳定的（选择）不适用。 归并中的计算，逆序对的数量由3个部分组成：逆序对数量=左半部分的逆序对数量+右半部分的逆序对数量+合并部分的逆序对数量。 令i作为左半数组的遍历索引，j作为右半数组的遍历索引。在合并的任何时刻，一旦发现a[i] 比 a[j] 大，那么会有 (mid – i + 1) 个逆序对。因为a[i+1], a[i+2] … a[mid-1] 都比a[j] 大。 那么最后在merge中加入相应的计数即可。]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序对计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用泊松过程生成空间点的程序》]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%8A%E7%94%A8%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B%E7%94%9F%E6%88%90%E7%A9%BA%E9%97%B4%E7%82%B9%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本文翻译自利兹大学采矿与矿物工程系《用泊松过程生成空间点的程序》，涉及到齐次泊松过程、非齐次泊松过程和泊松簇过程几章的部分内容，仅供参考。部分公式导入有问题，直接上图。 其中例子多应用于地质分析，对其他分析也有一定帮助。 POSISSON用泊松过程生成空间点的程序利兹大学采矿与矿物工程系 2002年9月 介绍 齐次泊松过程 非齐次泊松过程 泊松簇过程 1、介绍该程序的目的是实现在空间中利用用户定义的泊松过程生成空间点。程序实现的过程类型有：齐次泊松过程，非齐次泊松过程，泊松聚类过程，简单的Cox过程和简单的布尔模型。 实现是在一个矩形区域中构造的A=[x1,x2]*[y1,y2] 其中x1,x2和y1,y2可以被指定。 被划分为方形单元格，每个单元格被视为一个全有界的Borel集合。和中的单元格的数量也可以由程序的用户指定。对于这种安排，所有的细胞是不相交的，因此每个细胞的泊松点的模拟可以独立完成。 要使用的命令全部列在“SpatialPattern”的主菜单下。 选择相应的命令将弹出相关的参数指定窗口。 关闭窗口将激活模拟，一旦过程结束，将显示生成的点。 2、齐次泊松过程 3、非齐次泊松过程 4、泊松簇过程泊松聚类过程为建模具有聚合特征的空间点模式或空间聚类提供了一种工具。 在实践中，它也经常被称为父女建模，或者是层次模型，在这种情况下，父女之间的关系可以有多代，例如Lee和Einstein提到的那一个[3]。泊松聚类过程实际上由两个独立的过程组成，父过程和下一个过程。最后一点的模式通常只由后代（子过程）组成，尽管在某些特殊情况下父过程被包括在内以避免子代大小为0的集群[1]。 泊松聚类过程的实现将具有以下三个特点：父事件是从泊松过程生成的。 该过程可以是均匀密度λ的齐次泊松过程，密度函数λ（X）的非齐次泊松过程，双随机（Cox）泊松过程，或者甚至是另一种情况下的多代亲子模型 正在建设中。 在泊松聚类建模中，这被称为父流程，它为任何后续的子流程奠定了基础，这是以下两个定义的组合。 在这个步骤中获得了N个父母。 许多有趣的泊松聚类过程可以通过最后两个属性的变化来创建。一些已知的过程包括Neyman-Scott聚类过程，该过程用于描述子点独立且分布相同的聚类过程以及Matérn聚类过程，其中父过程是均匀的泊松过程，每个父过程产生产生的后代的泊松数具有相同的分布均值，参见van Lieshout [8]。 对于子过程点位置分布，文献中常见的模式是以母点为中心的半径r内的一个球（3D）或一个圆（二维）内的子点均匀分布，或由给定的PDF 决定。通常假设各向同性分布，即使有一些优先各向异性方向的分布也被提出。 为了生成泊松聚类过程的实现，需要首先生成父过程。 如上所述，父进程可以是同构的或非同类的进程，或者如果对层次结构进行建模，它甚至可以是集群进程本身。 一旦父过程的模型准备好了，就可以继续产生子过程了。图8显示了在实现女儿的程序中实现的选项。 对于每个亲本的后代数量，有三种选择：可以设置为固定数量，可以从指定的均匀分布生成，或者可以从定义的泊松分布生成（因此定义Metérn过程）。 为了将子过程点分配给他们的父过程，实施了两类分配：在椭圆内均匀分布或根据指定的PDF函数分配。对于每个类别，可以指定一个优先分配方向的进一步选项，详细说明见图6和图7。 每个父母的分布椭圆可以固定其轴和主轴方位角，或者这些属性可以根据指定的分布随机地为每个父过程生成。对于裂缝模拟，更可能是后一种情况，因为母体裂缝可能有不同的大小和方位，直接决定了分布椭圆的属性。如果女儿的位置是按照一个已知的模型分配的，那么模型只需要输入到选项3（图8）给出的数据框中。例如，对于径向对称的正常PDF： 图6 传统的父-子过程分配模式 图7 子裂缝位置分布的特殊考虑 图9 当子过程点均匀地分布在以父母为中心的椭圆内（父母是一个密度λ= 10的均匀泊松过程的实现），Poisson簇过程的一些实现。 图10 根据指定的普通PDF模型分配子过程的Poisson簇过程的一些实现（父母是密度λ= 10的均匀泊松过程的一个实现）]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>泊松点过程（PPP）</tag>
        <tag>泊松簇过程（PCP）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[start]]></title>
    <url>%2F2018%2F07%2F22%2Fstart%2F</url>
    <content type="text"><![CDATA[Start Hexo]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
