<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于最短路径（SP）的三个小问题]]></title>
    <url>%2F2020%2F05%2F11%2F%E5%85%B3%E4%BA%8E%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88SP%EF%BC%89%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Cousera 《Algorithms II》课程作业 Shortest Path (SP) 给定一个加权图，即图的边有权重。求两个节点之间的最短路径（SP)。 SP Assignment 👉 题目资料 链接 👉 代码 1、三个问题Q1. Monotonic shortest path - 单调最短路径给定一个有 E 条边的边加权有向图 G，已知起点 s，找到从 s 到其他每个顶点的 单调最短路径。 一条路径上每个边缘的权重严格增加或严格减少，则该路径是单调的。要求时间复杂度是 O(ElogE)。 题干对于图的限制没有明确说明。但是从复杂度约束 O(ElogE) 来看，可以判断以 Dijkstra 算法为基础。因此我们这里就假设是无负边的图。那么直接 Dijkstra 更新最小距离的部分加一个判断-当前边和上一条边的权重比较是否单调即可。这里用到了 algs4 中的 DirectedEdge、EdgeWeightedDigraph、IndexMinPQ 等类。 A: 在 relax() 时，更新 distTo[] 同时比较单调性。先递增查询一次，再递减查询一次。关键 code 如下： int 变量 ascend 用 1 或 -1 表示单调方向。完整代码 👉 code 123456789101112private void relax(EdgeWeightedDigraph G, int v, int ascend) &#123; for (DirectedEdge e : G.adj(v)) &#123; int w = e.to(); DirectedEdge lastEdge = edgeTo[v]; if (lastEdge == null || (e.weight() * ascend &gt; lastEdge.weight() * ascend) &amp;&amp; distTo[w] &gt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.changeKey(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125;&#125; 参考资料： Find a monotonic shortest path in a graph in O(ElogV) Q2. Second shortest path - 次短路径给定一个加权有向图，令 P 为从顶点 s 到顶点 t 的最短路径。 设计一个 Elog(V) 的算法，以查找从 s 到 t 的除 P 以外最短的路径（不局限于简单路径）。这里假设所有边缘权重严格为正。 无负边使问题简单很多。由于给出了最短路径 P，求第二短的路径，在图中将 P 中最后一条指向 t 的边去掉后，再使用 Dijkstra 算法求解最短路径即可。对于两点之间的路径，当优先队列中加入节点 t 时即可停止。同样这里用到了 algs4 中的 DijkstraSP 等类。 A: 关键 code 如下。使用一个变量 delEdge 保存最短路径中到达节点 t 的边。去掉该边，再次寻找 s-t 的最短路径。若客户端没有给出最短路径，可以先运行一遍 Dijkstra 找出。最关键是找到需要去掉的边。完整代码 👉 code 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SecondSP &#123; private int s, t; private double distTo[]; private DirectedEdge[] edgeTo; private IndexMinPQ&lt;Double&gt; pq; private DirectedEdge delEdge; public SecondSP(EdgeWeightedDigraph G, Stack&lt;DirectedEdge&gt; P, int s, int t) &#123; this.s = s; this.t = t; int V = G.V(); edgeTo = new DirectedEdge[V]; distTo = new double[V]; for (int v = 0; v &lt; V; v++) &#123; distTo[v] = Double.POSITIVE_INFINITY; &#125; distTo[s] = 0.0; pq = new IndexMinPQ&lt;&gt;(V); while (!P.isEmpty()) &#123; delEdge = P.pop(); &#125; pq.insert(s, 0.0); while (!pq.isEmpty()) &#123; int v = pq.delMin(); if (v == t) break; // 遍历到点 t 即结束 relax(G, v); &#125; &#125; private void relax(EdgeWeightedDigraph G, int v) &#123; for (DirectedEdge e : G.adj(v)) &#123; if (e == delEdge) continue; //去掉 delEdge 边，relax()中唯一添加的一句 int w = e.to(); if (distTo[w] &gt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.changeKey(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125; &#125;&#125; Q3. Shortest path with one skippable edge - 拥有一条可跳过的边的最短路径给定一个加权有向图，设计一个 O(ElogV) 算法以找到从 s 到 t 的最短路径，可以将其中任何一条边的权重改为 0。假设边的权重都是非负的。 不是很理解这题意思。这题直接看的 solution：计算从 s 到其他每个顶点的最短路径，再计算从每个顶点到 t 的最短路径。 对于每个边 e=(v, w)，计算从 s 到 v 的最短路径的长度与从 w 到 t 的最短路径的长度之和。总和最小的路径即为解。按照 solution 的意思：将图中任意一条边权重改为 0，那会产生 e 个新的图，求这 e 个图里 s-t 的最短路径。那么还是要用到 algs4 中的 DijkstraSP 类。之后简单遍历寻找即可。 A: 代码如下，用一个 DijkstraSP 数组保存每个节点的最短路径树。再按照 Solution 判断即可。需要用一个 Iterable 的变量保存最后的路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class EdgeSkippableSP &#123; private DijkstraSP[] sps; // 储存每个点到其他所有点的最短路径 private double minPathWeight; private Queue&lt;DirectedEdge&gt; skippableSP; public EdgeSkippableSP(EdgeWeightedDigraph G, int s, int t) &#123; sps = new DijkstraSP[G.V()]; skippableSP = new Queue&lt;&gt;(); for (int v = 0; v &lt; G.V(); v++) &#123; sps[v] = new DijkstraSP(G, v); &#125; minPathWeight = Double.POSITIVE_INFINITY; DirectedEdge minE = null; for (DirectedEdge e : G.edges()) &#123; int v = e.from(), w = e.to(); // 按照边来遍历： skip掉该边长，路径是否最短 if (sps[s].distTo(v) + sps[w].distTo(t) &lt; minPathWeight) &#123; minPathWeight = sps[s].distTo(v) + sps[w].distTo(t); minE = e; &#125; &#125; for (DirectedEdge e : sps[s].pathTo(minE.from())) &#123; skippableSP.enqueue(e); &#125; skippableSP.enqueue(minE); for (DirectedEdge e : sps[minE.to()].pathTo(t)) &#123; skippableSP.enqueue(e); &#125; minPathWeight += minE.weight(); &#125; public Iterable&lt;DirectedEdge&gt; getPath() &#123; return skippableSP; &#125; public double getMinPathWeight() &#123; return minPathWeight; &#125; public static void main(String[] args) &#123; In in = new In(args[0]); int s = 0, t = 2; EdgeWeightedDigraph G = new EdgeWeightedDigraph(in); EdgeSkippableSP sp = new EdgeSkippableSP(G, s, t); if (sp.getPath() != null) &#123; StdOut.printf("%d to %d (%.2f) ", s, t, sp.getMinPathWeight()); for (DirectedEdge e : sp.getPath()) &#123; StdOut.print(e + " "); &#125; StdOut.println(); &#125; else &#123; StdOut.printf("%d to %d no path\n", s, t); &#125; &#125;]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>图</tag>
        <tag>最短路径</tag>
        <tag>sp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于最小生成树（MST）的三个小问题]]></title>
    <url>%2F2020%2F03%2F06%2F%E5%85%B3%E4%BA%8E%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MST%EF%BC%89%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Cousera 《Algorithms II》课程作业 Minimum Spanning Tree (MST) 生成树为包含图所有顶点的无环连通子图，树中所有边的权值之和最小的生成树即为最小生成树（MST)。 MST Assignment 👉 题目资料 链接 👉 代码 1、三个问题Q1. Bottleneck minimum spanning tree - 最小瓶颈生成树一个生成树的瓶颈容量为最大边的权重。最小瓶颈生成树 即为瓶颈容量最小的生成树。设计一个寻找最小瓶颈生成树的算法。 A: MST 一定是最小瓶颈生成树，即最小生成树是最小瓶颈生成树的充分不必要条件，因此用 prim 算法或 kruskal 算法即可获得。Coding 可见 algs4 中的 PrimMST.java &amp; KruskalMST.java Q2. Is an edge in a MST? - 一条边是否在 MST 内？判断一条边是否是 MST 中的边。设计一个线性复杂度的算法。 A: 线性复杂度则不能通过寻找 MST 的方法。可以通过参考资料中的算法，边 e 两端的顶点分别为 u，v。删除边 e，寻找是否有由权重小于等于 e 的边组成的路径使得 uv 连通。具体代码如下，这里用到了 algs4 中的 Edge 类和 EdgeWeightedGraph 类等。 1234567891011121314151617181920212223242526public class IsEInMST &#123; private boolean[] marked; private double weightE; private int v, w; // vertexs of the given edge e; public IsEInMST(EdgeWeightedGraph G, Edge e) &#123; marked = new boolean[G.V()]; weightE = e.weight(); v = e.either(); w = e.other(v); dfs(G, v); &#125; public boolean inMST() &#123; return !marked[w]; &#125; private void dfs(EdgeWeightedGraph G, int v) &#123; marked[v] = true; if (marked[w]) return; for (Edge e : G.adj(v)) &#123; if(e.weight() &lt; weightE &amp;&amp; !marked[e.other(v)]) &#123; dfs(G, e.other(v)); &#125; &#125; &#125;&#125; 参考资料： 中文证明 英文证明 Q3. Minimum-weight feedback edge set - 最小权重反馈边集反馈边集合是指包含无向图中每一个环的至少一条边的集合。如果从图中移除反馈边集，得到的图无环。设计一个算法找到最小权重的反馈边集（假设所有边的权重为正）。 A: 即求解图最大生成树，对最大生成树所在边求补集即为最小权重反馈边集。通过调整最小堆为最大堆，利用 Prim 算法或 Kruskal 算法均可以实现。具体代码如下： MinFeedbackEdgeSet 类用于调用最大生成树算法和返回集合结果PrimMaxST 类为求解最大生成树的 Prim 版本，将优先索引队列改为最大堆实现KruskalMaxST 类为求解最大生成树的 Kruskal 版本，将优先队列改为最大堆实现 MinFeedbackEdgeSet.java 12345678910111213141516171819public class MinFeedbackEdgeSet &#123; private HashSet&lt;Edge&gt; minFeedbackEdgeSet; public MinFeedbackEdgeSet(EdgeWeightedGraph G) &#123; minFeedbackEdgeSet = new HashSet&lt;&gt;(); for (Edge e : G.edges()) &#123; minFeedbackEdgeSet.add(e); &#125; PrimMaxST maxST = new PrimMaxST(G); // or KruskalMaxST for (Edge e : maxST.edges()) &#123; minFeedbackEdgeSet.remove(e); &#125; &#125; // return Set public Set&lt;Edge&gt; getMinFeedbackEdgeSet() &#123; return minFeedbackEdgeSet; &#125;&#125; PrimMaxST.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class PrimMaxST &#123; private Edge[] edgeTo; // edgeTo[v] = largest edge from tree vertex to non-tree vertex private double[] distTo; // distTo[v] = weight of largest such edge private boolean[] marked; // mark[v] = true if v on tree private IndexMaxPQ&lt;Double&gt; pq; public PrimMaxST(EdgeWeightedGraph G) &#123; edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; pq = new IndexMaxPQ&lt;&gt;(G.V()); for (int v = 0 ; v &lt; G.V(); v++) distTo[v] = Double.NEGATIVE_INFINITY; for (int v= 0; v &lt; G.V(); v++) if (!marked[v]) prim(G, v); &#125; private void prim(EdgeWeightedGraph G, int s) &#123; distTo[s] = 0.0; pq.insert(s, distTo[s]); while(!pq.isEmpty()) &#123; int v = pq.delMax(); scan(G, v); &#125; &#125; private void scan(EdgeWeightedGraph G, int v) &#123; marked[v] = true; for (Edge e : G.adj(v)) &#123; int w = e.other(v); if (marked[w]) continue; if (e.weight() &gt; distTo[w]) &#123; distTo[w] = e.weight(); edgeTo[w] = e; if (pq.contains(w)) pq.increaseKey(w, distTo[w]); // update distance else pq.insert(w, distTo[w]); &#125; &#125; &#125; public Iterable&lt;Edge&gt; edges() &#123; Queue&lt;Edge&gt; maxST = new Queue&lt;&gt;(); for (int v = 0; v &lt; edgeTo.length; v++) &#123; Edge e = edgeTo[v]; if (e != null) &#123; maxST.enqueue(e); &#125; &#125; return maxST; &#125; public double weight() &#123; double weight = 0.0; for (Edge e : edges()) weight += e.weight(); return weight; &#125;&#125; KruskalMaxST.java 1234567891011121314151617181920212223242526272829public class KruskalMaxST &#123; private double weight; // weight of MaxST private Queue&lt;Edge&gt; maxST = new Queue&lt;&gt;(); // edges in MaxST public KruskalMaxST(EdgeWeightedGraph G) &#123; MaxPQ&lt;Edge&gt; pq = new MaxPQ&lt;&gt;(); for (Edge e : G.edges()) &#123; pq.insert(e); &#125; // greedy algorithm, need to use union-find to union all the forests UF uf = new UF(G.V()); while (!pq.isEmpty() &amp;&amp; maxST.size() &lt; G.V() - 1) &#123; Edge e = pq.delMax(); int v = e.either(), w = e.other(v); if (!uf.connected(v, w)) &#123; uf.union(v, w); maxST.enqueue(e); weight += e.weight(); &#125; &#125; &#125; public Iterable&lt;Edge&gt; edges() &#123;return maxST;&#125; public double getWeight() &#123; return weight;&#125;;&#125; 2、总结 回顾 IndexMinPQ 的实现方法，用两个数组关联 index 和 key 的位置 回顾 Prim 算法，分为两种，lazy 型的只用一个优先队列即可，添加所有的边。时间复杂度 O()；egar 型的实时更新，只保留最小边和其权重。 回顾 Kruskal 算法，需要利用查并集。 学习图论的一些知识 奇奇怪怪的知识又增加了]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>图</tag>
        <tag>最小生成树</tag>
        <tag>mst</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】具有远程社交联系行为的混合无线网络的容量]]></title>
    <url>%2F2019%2F12%2F17%2F%E3%80%90%E8%AF%91%E3%80%91%E5%85%B7%E6%9C%89%E8%BF%9C%E7%A8%8B%E7%A4%BE%E4%BA%A4%E8%81%94%E7%B3%BB%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%B7%B7%E5%90%88%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%B9%E9%87%8F%2F</url>
    <content type="text"><![CDATA[翻译自西电 PaperCapacity of Hybrid Wire$L$ess Networks With $L$ong-Range Socia$L$ Contacts Behavior 混合无线网络由 ad hoc 传输和蜂窝传输组成。在 最大 $L$ 跳路由 策略下，如果源和目的地在 $L$ 跳以内，则以 ad hoc 模式传输,否则以蜂窝模式发送。可以找到最佳 $L$ 使网络容量最大化。 具有远程社交联系行为的混合无线网络的容量摘要： 混合无线网络由 ad hoc 传输和蜂窝传输组成。在 最大 $L$ 跳路由 策略下，如果源和目的地在 $L$ 跳以内，则以 ad hoc 模式传输,否则以蜂窝模式发送。现有工作研究了混合无线网络容量与跳数 $L$ 的关系，以找到最佳 $L$ 使网络容量最大化。本文考虑了另外两个因素：传输模型 和 上行接入基站访问模式。现有研究大部分仅考虑均匀分布传输模型，本文则考虑了具有社会行为的传输模型。这里研究了传输模型对最佳路由策略的影响。此外，这里还考虑两种不同的接入模式：单跳接入（每个节点直接与基站通信）和多跳接入（由于功率限制，节点可以通过多跳访问基站）。本文也研究了这两种不同接入模式对最佳路由策略的影响。本文得到了以下结果： 1）最优 $L$ 不仅取决于传输模式，还取决于接入基站模式； 2）单跳访问比多跳访问提供更高的网络容量，但以增加发射功率为代价； 3）在单跳接入模式下，网络容量随基站数量线性增长；但是，它不适用于多跳访问模式，并且基站数量对不同流量模型的网络容量有不同的影响。 介绍研究网络容量是一项巨大的挑战，也是深刻理解无线网络提供的服务能力的一项非常重要的工作。Gupta 和 Kumar 是对纯自组织网络的容量进行广泛研究的开拓者[1]。在具有信道容量 $W$ 的 $n$ 个节点的网络中，当每个节点随机且独立地选择网络中的另一个节点作为其目的地时，平均节点吞吐量为 $Θ（\frac{W}{\sqrt{n$L$ogn}}）$。 Gupta 等人建议将基站引入网络以提高网络容量。当路径较长时，可以由基站转发数据包。由于两个基站之间的传输是通过有线网络进行的，因此可以减少无线资源的消耗。由 ad hoc 传输和蜂窝传输组成的网络称为混合无线网络。 图 1 表示了从[2]中的混合无线网络。 路由策略是影响网络容量的主要因素。给定一个从源节点到目的节点的传输流，路由策略确定该流是在 ad hoc 层还是在蜂窝层上传输的。现有研究采用两种路由策略：相同的小区路由策略[3]和最大 $L$ 跳路由策略[4]。使用相同的小区路由策略，如果两个节点位于同一小区中，则它们以自组织方式进行通信。 否则，它们通过基站进行通信。如果应用最大 $L$ 跳路路由策略，则在源和目标距离在 $L$ 跳以内的情况下，在 ad hoc 层上传输该流； 否则，流在蜂窝层上传输。本文考虑了最大 $L$ 跳路由策略。 直观地，$L$ 的变化将影响网络吞吐量。当 $L$ 太小时，走 ad hoc 层的传输流有限，可能无法充分利用自组织资源。反之如果 $L$ 太大，则在 ad hoc 层中传输许多长距离流，并且由于干扰，每次传输消耗更多的无线 ad hoc 资源。因此，存在一个最佳 $L$ 以最大化网络吞吐量。这项工作旨在研究网络吞吐能力和 $L$ 间的函数关系，以及找到最佳 L。 研究网络容量常用几个指标。Gupta 和 Kumar 提出了两个新的网络容量概念：吞吐能力和传输能力[1]。吞吐能力是指每个源每秒可以将其传输到目的地的 bit 数的时间平均值，而网络的传输能力则表示每秒 bit 与其传输距离的乘积。例如，如果每秒在两米上传送 $2bit$，则网络的传输容量为 $4bit·m$。吞吐能力和传输能力都量化了源目的地对之间端到端的通信能力，对于描述网络拓扑，路由机制和调度算法对网络容量的影响有很大作用。另一个度量标准——传输容量，常与中断概率一起使用，量化了大型无线网络中可实现的单跳速率。分析传输容量通常采用单跳流量模型，并且重点关注物理层对网络容量的影响。本文研究了路由策略对混合无线网络容量的影响，因此将重点放在吞吐量的分析上。 现有关于网络容量的大多数工作都采用统一的流量模型，即每个源都随机选择一个节点作为其目的地。实际上，流量取决于用户的行为[5]。众所周知，小世界现象普遍存在于自然和技术领域中的各种网络中，并且是万维网发展的基本要素。瓦茨和斯特罗加茨（Watts and Strogatz）提出了一种小世界现象的模型，该模型将社交网络的联系人分为本地联系人和远程联系人[6]。源节点通常非常频繁地与其邻居联系，但是有时，源节点还会联系远离源节点的目标。在文献[6]提出的模型中，一个源节点随机选择其远程联系，其概率与 α-功率分布的倒数成正比，这是我们草案中的远程社交联系交通模型。本地联系人表示从源节点到其邻居的通信。如果所有业务都是本地联系业务，则不会使用基站进行数据传输，并且网络容量与纯自组织网络中的网络容量相同。在这项工作中，我们使用远程社交流量模型研究混合无线网络的容量。我们旨在捕获联合路由策略和流量模型对混合无线网络容量的影响。]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
        <tag>混合网络</tag>
        <tag>Ad Hoc 网络</tag>
        <tag>网络容量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordNet]]></title>
    <url>%2F2019%2F11%2F06%2FWordNet%2F</url>
    <content type="text"><![CDATA[Cousera 《Algorithms II》课程作业 WordNet 由自于普林斯顿大学设计，是一种基于认知语言学的英语词典。综合了语言学，计算机等相关学科指示，按照词义将单词整理出同义词组和上下义关联关系，形成的一个网络。 WordNet Assignment 题目资料 链接 代码 1、题目背景1. WordNetWordNet 由自于普林斯顿大学设计，是一种基于认知语言学的英语词典。综合了语言学，计算机等相关学科指示，按照词义将单词整理出同义词组和上下义关联关系，形成的一个网络。 一些概念 同义词集 - synsets：语义相同的一组单词 上义词 - hypernym：对事物的概括性、抽象性说明 下义词 - hyponym：对事物的具体表现形式或更为具体的说明 参考文献 百度 wordnet 2. BFS广度优先搜索，利用队列（queue）实现的一种暴力搜索算法，最简便的图的搜索算法之一。 相比 DFS 利用栈结构（stack）递归进项搜索，容易理解，BFS 会更经常用于与“最小”/“最短”等关键词相关的图问题。 Dijkstra 单源最短路径算法和 Prim 最小生成树算法都采用了和宽度优先搜索类似的思想。 DFS 和 BFS 2、题目描述题目资料 链接 总结为以下 4 点： 给定两个节点，寻找有向图中两个节点的最短距离&amp;公共祖先 给出两个节点的集合，寻找两个集合中距离最短的两个节点的距离和公共祖先 给出两个输入文件，构建有向图 节点 id 所对应的同义词集 synsets.txt 词集间 id 的上下义关系 hypernyms.txt 给出一组词组，寻找这组词当中最无关的一项 3、文件结构引用外部类 - algs4.jar Digraph.java BreadthFirstDirectedPaths.java 自身类 SAP.java WordNet.java Outcast.java 4、解决思路暴力求解引用外部类1. SAP.javaSAP.java 主要完成利用 bfs 算法，在有向图中寻找共同祖先和最小路径长度的问题。构造函数输入该有向图，其中提供了两个 API length() 和 ancestor()： 123456789101112131415public int length(int v, int w) &#123; return bfsSearch(v, w)[0];&#125;public int length(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) &#123; return bfsSearch(v, w)[0];&#125;public int ancestor(int v, int w) &#123; return bfsSearch(v, w)[1];&#125;public int ancestor(Iterable&lt;Integer&gt; v, Iterable&lt;Integer&gt; w) &#123; return bfsSearch(v, w)[1];&#125; 关于路径长度和祖先的定义，下图是个简单的示意。在一个有向图中，给定两个节点 v，w，则它们之间的 length 为两者都可到达某一个节点时，最小的边的数量，祖先节点即为该节点。当输入是两个节点的可迭代集合，表示寻找两个集合中拥有最短长度的两个节点的 length 和 ancestor。具体描述见：题目资料 链接 对于SAP.java的实现，这种方法使用到了官方 algs4.jar 包中的BreadthDirectedFirstPaths.java类 12345678910111213141516171819&gt; // BFS from single source&gt; private void bfs(Digraph G, int s) &#123;&gt; Queue&lt;Integer&gt; q = new Queue&lt;Integer&gt;();&gt; marked[s] = true;&gt; distTo[s] = 0;&gt; q.enqueue(s);&gt; while (!q.isEmpty()) &#123;&gt; int v = q.dequeue();&gt; for (int w : G.adj(v)) &#123;&gt; if (!marked[w]) &#123;&gt; edgeTo[w] = v;&gt; distTo[w] = distTo[v] + 1;&gt; marked[w] = true;&gt; q.enqueue(w);&gt; &#125;&gt; &#125;&gt; &#125;&gt; &#125;&gt; 上面是 BreadthDirectedFirstPaths.java 中 bfs 的实现。marked[] 保存节点是否已经走过，distTo[] 记录从节点 s 到该节点的最短长度。这容易理解，因为广度优先，循环到当前节点即为最短路。普通的利用 queue 保存当前节点 v 的所有邻居，v 出队，v 的所有邻居判断完之后入队。如果输入为节点集合，则初始化 queue 时，需要把集合内所有节点入队。若节点 d 不可由 s 到达，marked[d]=false。 该版本 SAP.java 的基本思想是，对节点 or 节点集合 v 和 w 分别计算到其它所有点的最短路径。之后遍历一遍所有节点，判断是否同时可达 v 和 w，若可以则记录并更新 min length。主要由 bfsSearch() 方法完成。 2. WordNet.javaWordNet.java 主要完成从给定的同义词集 synsets.txt 和上义词关系 hypernyms.txt 中，构建有向图的功能。synsets.txt 中有三个域，每一个节点对应一个 id ，一个 id 映射到一个同义词集中，这个同义词集中包含多个词(word)，最后一个域是对这一组词的解释，对于图的构建没有作用。hypernyms.txt 中给了节点间的指向关系，即有向图的边。 主要 API 如下： 123456789// is the word a WordNet noun?public boolean isNoun(String word)// distance between nounA and nounB (defined below)public int distance(String nounA, String nounB)// a synset (second field of synsets.txt) that is the common ancestor of nounA and nounB// in a shortest ancestral path (defined below)public String sap(String nounA, String nounB) 在 SAP.java 已经确定的情况下，这一部分仅为简单的输入字符串处理，构建有向图的过程，用到了 algs4.jar 中的 Digraph.java 类。输入两个词，寻找他们的共同上义词和距离，均可使用 SAP.java 中的方法。 节点对在这个版本中用了两个 map：一个 key 为 id，value 为对应的 synset。由于不涉及查找，这里可以直接用数组来优化；另一个 key 为单词，value 为该单词所在的节点的 list（因为一次多义，可能属于多个 id）。这个 map 用于 distance() 和判断单词是否属于该词典 isNoun() 两个 API。 3. OutCast.java输入一组词，利用 WordNet.java 中的 distance() 方法计算每个词与其他词的距离之和。和最大的单词即为 OutCast。 问题&amp;优化1. Coding Styles1) excessive boxing初始代码中有这样一句报 warning： 12int id = Integer.valueOf(realms[0]);//Warning：converts String to primitive using excessive boxing 问题出于对装箱(boxing)这个概念不太了解，而且 java 中有自动装箱机制，平时没注意过。 装箱 就是把“值类型”转换成“引用类型”；对应的拆箱(unboxing)就是把“引用类型”转换成“值类型”。值类型一般来说是创建在栈中，引用对象的指针在栈中创建，实际对象则存于堆内存中。 怎么修改？由于 valueOf 返回的是 Integer 包装类，而 parseInt 返回的是 int 基本类型 In summary, parseInt(String) returns a primitive int, whereas valueOf(String) returns a new Integer() object. 装箱&amp;拆箱 Integer.valueOf() vs Integer.parseInt() Java 自动装箱与拆箱及其陷阱 Java 基础之自动装箱和自动拆箱源码分析 2) new String() 和字面量赋值初始化 String 变量时有这样一个 warning 12String outcast = new String();//Warning：Creates the empty string using 'new String()'. Use the string literal "" instead. nice！ 因为这个问题又复习了一遍 JVM。正式运行程序时，.class 文件中的大部分数据被加载到运行时常量池中。此时字符串本体仍被创建在堆内存中。而在永生代方法区之外，保存有一个字符串常量池，里面储存该字符串对象的引用。使用字面量创建时，虚拟机会先从字符创常量池中找是否有值相等的引用，如果有则返回这个引用。 123String str1 = "string";String str2 = "string";String str3 = new String("string"); 所以以上 str1 和 str2 的指向同一个堆内存地址，str3 在堆中申请了新的地址创建新的对象。 下面的资料生动形象地说明发生了什么： java 用这样的方式生成字符串：String str = “Hello”，到底有没有在堆中创建对象？ JVM Interval 3) final 变量的使用需要考虑变量不发生变化时，使用 final 修饰符提高性能。 final of Java 2. Edge cases1) null 的判断输入参数是 list 是，注意判断内部元素是否为 null 2）immutable 的 SAP.Java这里有要求说 SAP.java 类需要是不可变的，但是构建时使用了 Digraph 类是可变的，因此需要 new 一个拷贝，不能直接引用。 3）rooted DAG要求判断输入的图是否是只有一个根的有向无环图。根据每个节点的出度判断。 3. 优化在 bfs 中可以对两个节点轮询查找，找到共同祖先后终止循环，减少循环次数。参考https://www.cnblogs.com/mingyueanyao/p/9166441.html 综上，code 详见：👉here 5、总结 了解了 WordNet 及语义处理的基本概念 加深理解有向图结构及方法 加深理解 BFS 算法 积累 null 及相关边界条件处理经验 熟悉 java 装箱 拆箱机制 复习 final 关键字的用法 复习了 jvm 基本知识]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>bfs</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序分享功能]]></title>
    <url>%2F2019%2F09%2F13%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[目前微信内分享常见三种形式，推荐到好物圈，朋友圈分享，微信好友/群分享。 朋友圈分享，目前来看大多用画图来完成。由于微信没有提供直接分享朋友圈的接口，因此各路神通想出了：生成图片保存相册，转发朋友圈，扫图中小程序码的“三段跳”解决方案。这样在海报样式上能做更大的文章。比如插入用户信息，产品的信息，更酷炫的设计等等。 微信小程序分享功能知识点最近开发微信小程序，记录一些重要的知识点。部分内容引用自微信官方文档。 概览 概览部分引用自《微信开放文档》 小程序与普通网页开发的区别网页开发的渲染线程和脚本线程是互斥的，因此长时间运行脚本可能导致页面失去响应。 在小程序中，渲染和脚本分别运行在不同的线程中。 逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API。这导致一些常用库（jQuery、 Zepto 等），在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的1。 1. 微信开放文档 &#8617; 小程序运行机制启动 热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动。 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。 小程序没有重启的概念。 前台/后台状态当用户点击右上角胶囊按钮关闭小程序，或者按了设备 Home 键离开微信时，小程序并没有直接销毁，而是进入了后台状态； 当用户再次进入微信或再次打开小程序，小程序又会从后台进入前台。 小程序销毁需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是 5 分钟）小程序会被微信主动销毁。当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。 在 iOS 上，当微信客户端在一定时间间隔内（目前是 5 秒）连续收到两次及以上系统内存告警时，会主动进行小程序的销毁，并提示用户 「该小程序可能导致微信响应变慢被终止」。 建议小程序在必要时使用 wx.onMemoryWarning 监听内存告警事件，进行必要的内存清理 在调试过程中，安卓小程序在后台显示为与 App 类似的实际 view，也就是说安卓用户可以手动销毁小程序，但在 IOS 系统上，小程序不显示。这一点还有待考证。 WXS 响应事件的动机由于视图层和逻辑层分开，有频繁用户交互的效果会比较卡顿。需要先将用户在视图层的 event 传进逻辑层，逻辑层处理完成之后通过 setData()再传入视图层。需要两次通信+一次渲染。setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。 因此 WXS 的使用的思路是减少通信的次数，让部分逻辑代码在视图层运行。 微信分享需求描述目前微信内分享常见三种形式，推荐到好物圈，朋友圈分享，微信好友/群分享 好物圈以插件形式存在，下文不具体涉及。 朋友圈分享，目前来看大多用画图来完成。由于微信没有提供直接分享朋友圈的接口，因此各路神通想出了：生成图片保存相册，转发朋友圈，扫图中小程序码的“三段跳”解决方案。这样在海报样式上能做更大的文章。比如插入用户信息，产品的信息，更酷炫的设计等等。 除了朋友圈分享这种方式，微信好友/群内分享也很常见。微信提供了很多 API，其中包括监听页面内转发事件。在转发的过程中默认截取当前页面为转发图。如果想要得到更酷炫的转发图，也需要用到 canvas 画图来生成。 微信在 Page 中提供了 onShareAppMessage 的事件处理函数，监听用户点击页面内转发按钮。该函数返回一个对象，用于自定义转发内容： 12345&#123; title: //标题 path: //转发路径 imgUrl: //自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径&#125; 因此，自然而然可以想到，在 imgUrl 上做文章。需要动态生成一张图片，并保存其 url。到此，思路便比较清晰了：生成图片可用 canvas 绘图，并利用微信提供的 API - wx.canvasToTempFilePath 得到本地图片 url。 程序流程分享图生成的画图方法在页面的生命周期中位置如下： 页面视图 wxml 文件中，button 绑定 onShareAppMessage()方法。同时设置 canvas 画布。利用 wxss 设置样式移到可见范围之外。 页面初次加载(onLoad)时，获取需要分享信息数据。可能同时包含有文字和图片信息。若图片来自网络，则会先下载到本地为画图备用。需要利用 wx.getImageInfo()，获得该图片的本地 url，在 success 回调函数中进行下一步处理画图。可以将该 API 包进一个 Promise 对象中返回，便于其他模块处理网络图片的链式调用和后续处理。 创建 canvas 上下文，利用 canvas 相关方法画图。关键的 draw()方法有三个重要参数，第一个表示是否保留画布之前内容，第二个为绘制完的回调函数。在回调函数中调用 wx.canvasToTempFilePath()，把当前画布指定区域的内容导出生成指定大小的图片。第三个为需要作用于的 this 对象。这一点很重要，因为需要在 wx.canvasToTempFilePath()成功后，在其 success 回调中，将生成图片的 url 设置为 page 的全局变量。这样能在 page 作用域内，将生成图片的 url 设置到事件处理函数 onShareAppMessage()当中。 FAQs 为什么不隐藏 canvas，设置 display:hidden canvas 标签隐藏会导致绘制失效 为什么在页面加载时就生成图片，而不是点击分享按钮后生成图片 在页面事件 onShareAppMessage()运行时，只有按规则返回具有对应参数的对象时，才能成功弹出分享到微信好友界面。（作者尝试通过 Promise 异步返回，但由于 wx 限制，若返回 Promise 对象便不能识别。）然而，在画图过程中调用的几个 API 均为异步方法，因此对于 page 页面的事件，无法做到先点击 share button，触发 onShareAppMessage()后，在该方法内调用其他异步绘图方法。这样无法得到新绘制图的 url。 关于 2 真的做不到吗？我不是很相信 具体见 4、同类小程序分享调研 第一次点分享按钮图片不是我想要的，退出再点击一次就好了 说明异步画图的 url 还没设置进去，用户就点击了分享按钮。这个时候显示默认的界面截图。退出后再点击的过程中，图片画好了，url 已生成也设置进去了，正常显示。 为了解决这个问题，可以添加一个 page 全局变量记录画图状态，已画完才显示 button，否则不显示。 新绘制的图片中可以将多张图片合成在一起吗？ 能，在用户授权后，还可以添加用户头像和昵称信息 同类小程序分享功能调研&amp;猜想唯品会：有信息，点击分享 button，加载约 1 秒，弹出 Component 组件。在组建内集和好物圈，微信好友，朋友圈三种分享方式。分别可点击，有不同效果。猜想：虽然不知道源码，但 share-button 基本和其他页面元素一同加载出来。点击 button 后有明显的 1 秒左右加载过程。笔者猜想 canvas 画图便设置在了这段时间内。注意这本质上也是先画图，再分享的过程。但在体验上完美地解决了问题 2 的整套动作。 网易考拉：无信息，只有一个网络图没处理 蘑菇街：有信息，在微信分享弹框内会有“。。。”等待加载。猜想：有时主图加载时显示为视频，此时若点击过快会出现只有一张图的情况。笔者猜想是由后端生成的图片，直接返回 url。点击过快可能信息还未返回，因此显示默认图片。 京东，拼多多，每日优鲜：有信息，点击过快只有主图猜想：前端画图，未处理分享按钮，因此若点击过快没画完，则设置为主图。 苏宁易购：类似唯品会的“二级跳”，但是点击一级分享按钮后，过一会才会生成分享微信好友的按钮。这段时间内，大概率在进行 canvas 画图。画完图之后显示分享按钮。 后端方案保险的做法，不受微信能力的限制。在后端画图，大体上需要提供两个 API。 画图并上传服务器，返回 URL。 通过刚才生成的 URL 拿到图片 存在的问题：后端画图无可厚非，不过在实际过程中，以 Java 为例，画图时间较长。如果加上来回前后端通信的时间，似乎时延是不可忍受的量级。同时由于该需求中需要显示的信息存在过期问题，缓存机制也将需要进一步考虑。 可能存在的 bug 人民币符号‘¥’在 ios 系统中显示可能出现问题 参考文献 微信开放文档 微信小程序前端生成图片用于分享朋友圈最终解决方案]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>分享到朋友圈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器社交和人类社交]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%9C%BA%E5%99%A8%E7%A4%BE%E4%BA%A4%E5%92%8C%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[今天看了社会学和脑科学中的一个社会脑理论 《The Social Brain Hypothesis》 Primates have larger brains relative to body size than all other vertebrates [1] and it is now widely accepted that the best functional predictor of relative brain size in non-human primates is social group size [2]. 本文属于杂记，非科学文章，感兴趣可以深入查找文献，善莫大焉。 今天看了社会学和脑科学中的一个社会脑理论 《The Social Brain Hypothesis》 Primates have larger brains relative to body size than all other vertebrates [1] and it is now widely accepted that the best functional predictor of relative brain size in non-human primates is social group size [2]. 就是说，人的社群规模和大脑尺寸之间的这种关联，有时被称作社会脑假说（social brain hypothesis）。也就是维持社会关系的能力越强，头……越大？ 基于社会脑假说计算出的人类社群规模应在 150 人左右，这个数字被称作“邓巴数”（Dunbar’s number）。事实证明，这也是一般人类社会团体和一般个人社交圈的人数。也就是说，社交群体的大小受到人脑能力的限制。 那么机器同理，而机器的大脑或许是电池，或许是 CPU 寿命，受种种因素的限制，其社群大小应该也是受限的。 为啥会想到这呢？ 之前导师提了个了词叫机器社交，虽然题目实在是太大，不过 5G 这波风口当下着眼点转向 IoT，想一想也不是完全没法讲这个故事。毕竟NB-IoT已经一些地区电表和智能家居试行了，更科幻的场景已经有电影及《底特律》这样的游戏帮我们构想了出来。 可能是从事相关行业，《底特律》这个游戏的确是让我深思。直观地想这样一个问题：人的心里状态和情绪状态是否是可计算的吗？这其实就是那个耳熟能详的哲学问题：人工智能是真正的智能吗？然而 真正的智能 本身还没有定义，因此很难说。 如果说如今的人工智能在思维和情感属性上和人类别无二致，也不是没有道理，当能源、存储空间、网络、材料、算力等发展再提升一个高度之后，机器也就大概率能达到人的基本形态了。皮肤可以人造，器官可以人造，血肉也可以（最近比尔·盖茨都投资推广人造肉了，2019.05），神经有电线，思维说到底就是巨型数据库，语言有 nlp、文本挖掘，视觉有 cv，所有经历过的事件及处理方式做训练集，可以把激素带入整个系统，那么快乐的时候分泌多巴胺，内啡肽 blabla，悲伤的时候分泌有害物质，如此情感和行为都可以抽象成训练的结果了。 所以这么来看，当科技发展到包括但不限于以上环节到一定水平时，如果可以做到环环相扣，不出 bug，基本上也就差不多变人了。在定义人类基本价值观-比如自由 平等 公正 法治…-是 好的 前提下，价值观也是可以训练出来的（否则教育的意义何在），当系统判断正在经历的事件不属于价值观体系中正常的事件，系统也会产生不满等消极情绪，真正的智能不也就是 AI 的高级形式了么。 估计到这个时候，人们又会讨论 我是谁 的哲学问题了，别说到时候，现在就已经开始讨论了哈哈哈哈。 当然我们不能排除有超自然力或者人类尚未发现的重大理论的存在，因此只能说一切都是基于现有认知的想象。 如果以上的假设成立，机器社交也会随之出现。其实上面这种范畴上的社交，属于高级意义上的，针对人类社会的社交。属于我上班摸鱼天马行空的想象，换句话说： 是我想太多]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
        <tag>社交网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 flex布局]]></title>
    <url>%2F2019%2F05%2F09%2FCSS3-flex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[在移动端适配，移动端开发中，或 APP 组件，页面栏目 or 小范围板块布局中常用的 flex 布局。 flex 布局是什么？自适应弹性布局 自动判断布局空间，修改自身尺寸 多个 box 在多个方向进行对齐&amp;分布 什么时候用？适用于什么场景？ 布局内部需要自适应 布局内部需要多个方向排列对齐 应用于： 移动端适配，移动端开发 APP 组件，页面栏目 or 小范围板块布局 基础概念 布局结构 双层结构：外层容器flex-container,激活弹性机制。内层flex-item自动获得相关特性。flex-container外部和flex-item内部元素不受影响。 flex 机制 任何一个容器都可以指定为 flex 布局，其内部第一层级的子项自动变为 flex 项目 `display:flex` 块状flex容器 `display:inline-flex`行间flex容器 一旦激活 flex 机制，子项的float、clear 和 vertical-align 属性失效 区域轴向 主轴 &amp; 交叉轴，flex 容器的两端为轴的起点和终点 flex 属性flex-container6 个属性，flex-item6 个属性 外围容器相关属性：1）对子项的排列和对齐 2）文档流入盒子的方向 flex-direction：定义主轴和交叉轴的方向 flex-wrap：换行 nowrap：往往对应自适应，外围容器固定，item 自动变化 flex-flow：文档流 flex-direction + flex-wrap 缩写 justify-content：主轴对齐（左中右，留白环绕，留白中间） align-items：交叉轴对齐 align-content：交叉轴多行的对齐方式（容器若只有一行，则无效，避免与align-items发生冲突） 那么问题来了：水平垂直居中的一个方式，就可以用flex布局实现 子项相关属性：子项的自适应伸缩及分配 flex-grow：扩展比例，分配的是剩余的空间（wrap），默认 0 不扩展 flex-shrink：收缩比例（nowrap)，默认 1 等比收缩 flex-basis：定义 item 在主轴上的基本尺寸(定义子项的基本宽 or 高)，默认 auto flex缩写 固定顺序（grow shrink basis）可省略。none auto（可扩展可收缩） 快捷写法：只写 grow shrink，默认忽略设定的width；只写 basis 默认可扩展可收缩。尽量使用 flex 复合写法。 align-self：子项自身的交叉轴对齐方式 order：子项的排列顺序，数值越小越靠前，可以负数 以上两个属于单独调整的两个属性 实例 什么时候想到用 flex - 移动端 - 单、多行垂直居中 - 需要垂直对齐的列表元素 - 单行选项卡 - 垂直弹性布局 - 分栏，一些栏定宽+其他栏自适应 练习 骰子 🎲（练习对齐）👉code 一栏定宽 + 一栏自适应 👉code tab 选项卡 👉code 垂直弹性布局：👉code 另一种方法：header footer position 固定位置注意对 overflow 和 超出视口部分滚动的设置 常见问题 简写 flex 属性，导致设定宽高无效 flex 容器中的文本自动成为 flex 子项，除了空格 子项的 float、clear 和 vertical-align 属性失效 如果子项是绝对定位，定位基准参考 flex 容器的content盒子。因为 flex 本身就是对其 content 的文档流进行操作 flex 子项的 margin：外边距合并失效，margin：auto 可自动分配剩余空间，达到垂直居中的效果，类似操作 flex 容器的主轴交叉轴对齐 flex 容器主轴和 writing-mode：一旦独立设定 writing-mode，优先级高于 flex 容器轴向操作，子项内的文字也会随writing-mode 改变 参考资料阮一峰-flex 布局 zhangwang-flex 属性]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯css实现选项卡]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[选项卡是个很常见的小组件，总结一下想到的知识点和方法 这里就拿一般意义上的横向选项卡来说，一般来说会结合点击/鼠标移入实现效果的变化，如下拉菜单，背景变化等。 选项卡是个很常见的小组件，总结一下想到的知识点和方法 这里就拿一般意义上的横向选项卡来说，一般来说会结合点击/鼠标移入实现效果的变化，如下拉菜单，背景变化等 布局 float 肯定是可以实现的，absolute+float:left+li，将列表横向布局实现。 如果用这种方法，免不了要想 浮动 可能引发的问题 - 父级高度塌陷。解决的方法也很容易搜到，“古老”方法可以在结构最后添加一个空div清除浮动；“现代”方法用::after伪元素也分分钟解决，注意要设置伪元素为块级元素block才能出现效果，加上clear:both 接下来可能会引申到两端对齐 还可以用inline-block+text-align: justify 实现两端对齐，不过其默认对最后一行无效，新浏览器可配合text-align-last: justify使用。面对兼容问题一样可以使用添加空div或者伪元素，设置display: inline-block，并设置宽度为 100% 另外也可以 flex ，操作更加容易一些 切换 利用 checked 及相关伪类利用input radio的单选特性实现切换，最后清除radio选项的视觉显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;!-- 纯css实现选项卡切换：利用checkbox及相关伪类 --&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #box &#123; width: 450px; background: whitesmoke; margin: 50px auto; padding: 20px; padding-top: 56px; border-radius: 8px; position: relative; &#125; #box span &#123; position: absolute; width: 150px; text-align: center; height: 36px; line-height: 36px; border-radius: 8px 8px 0 0; background: silver; top: 20px; &#125; #box label:nth-child(1) span&#123; left: 20px; &#125; #box label:nth-child(2) span&#123; left: 170px; &#125; #box label:nth-child(3) span&#123; left: 320px; &#125; #box ul&#123; margin: 0; padding: 0; list-style: none; background: white; padding: 10px; line-height: 26px; display: none; &#125; #box li&#123; height: 26px; overflow: hidden; &#125; #box li:hover&#123; color: orangered; &#125; #box input &#123; display: none; &#125; #box input:checked ~ ul &#123; display: block; &#125; #box input:checked ~ span &#123; background: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab1&quot; checked=&quot;checked&quot;/&gt; &lt;span&gt;今日要闻&lt;/span&gt; &lt;ul&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab2&quot; /&gt; &lt;span&gt;热门活动&lt;/span&gt; &lt;ul&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab3&quot; /&gt; &lt;span&gt;热点话题&lt;/span&gt; &lt;ul&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 利用 锚点实现 herf + :target利用a将href与对应的id绑定，调整显示层级z-index实现切换 要注意利用a的话，点击之后后会自动跳转到 以对应id元素为页面顶端的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; border: 1px black solid; position: relative; &#125; div span&#123; display: flex; &#125; div span&gt;a&#123; flex: 1; text-align: center; line-height: 48px; color: white; background: cornflowerblue; &#125; div ul li&#123; position: absolute; width: 100%; height: 20vw; background: red; left: 0; top: 48px; &#125; div :target&#123; z-index: 55; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; --&gt; &lt;div&gt; &lt;span&gt; &lt;a href=&quot;#tab1&quot;&gt;tab1&lt;/a&gt; &lt;a href=&quot;#tab2&quot;&gt;tab2&lt;/a&gt; &lt;a href=&quot;#tab3&quot;&gt;tab3&lt;/a&gt; &lt;/span&gt; &lt;ul&gt; &lt;li id=&quot;tab1&quot;&gt;tab content1&lt;/li&gt; &lt;li id=&quot;tab2&quot;&gt;tab content2&lt;/li&gt; &lt;li id=&quot;tab3&quot;&gt;tab content3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt;&lt;!-- &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 利用 js直观上想，可以直接利用 js onmouseover onclick 等实现，不过这就不属于纯 css 实现的范畴了]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2019%2F04%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[移动端适配1. 利用百分比实现宽高比固定想实现宽度自适应，高度随宽度变化而变化，宽高比固定。用height百分比显然不行，height百分比是以父元素高度为基准的，而此时需要以宽度为基准来设置高度。 所以这里可以用到padding-top或者padding-bottom，padding是以父元素的width为基准的。我们可以设置元素的height：0，然后用padding-bottom将元素撑开，以实现固定宽高比。 还可以利用vw，vh设置 2. rem以元素字体为基准的单位：默认font-size为16px的话，1rem=16px。可以根据 .clientWidth 读取屏幕宽度，并计算对应的尺寸。 3. 怎样适应视网膜分辨率？ 4. dpr 和 viewportdpr(device pixel ratio)设备像素比viewport 移动端有三: ideal viewport 理想大小，通常设为设备屏宽高 visual viewport 可视大小，整个page在屏幕中显示的大小, 不会超过layout layout viewport 布局大小，page页面的大小 通常页面不会完全显示，因此 visual viewport &lt;= layout viewport, 5. 关于flexible方案 如果 标签中设定了viewport，则取值已设定的 初始dpr 和 ideal viewport 的宽度大小（通常=device-width设备宽度） 若没有, 根据设备设置 dpr 和 缩放倍数（1/dpr）,压缩css像素，保证同等物理大小的范围里，css像素和物理像素比为1. 添加属性及标签 监听页面变化 更新根元素字体大小：这里如果页面宽度低于540px,那么页面中html的font-size也会按照（当前页面宽度/640）的比例变化 initial-dpr 的作用方式是：同时设置 visual viewport 和 layout viewport，如果width属性也有设定，则取二者较大值]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 怪诞行为学 的一些想法]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%85%B3%E4%BA%8E-%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.11.08 update9月份在实验室书架上发现了这本《怪诞行为学》，我自己是对心理学有毫无来由的喜爱，对不正常事件也充满了好奇，估计挺适合找bug的。一开始每天去书架那里看，后来情到深处就拿到自己那里看了，打算看完在放回去。 Dan Ariley 这本书2010年出版的，到现在都快10年了。不过其中的实验和例子非常有趣不乏味。 首先Dan描述了一场飞来横祸使其对行为经济学的兴趣大增的例子。Dan经历过一场镁光灯爆炸，全身70%的皮肤遭受三度烧伤。之后他引出了一个exceptional的问题：怎么撕绷带/膏药/创可贴一类的东西？ Dan恢复时每天要浸在消毒液里(?这里我很疑惑啊，想到了木乃伊)，刮掉坏死的皮肤，再包扎起来。每次换药都会牵扯到尚未完全愈合的伤口，必然非常疼痛。可以设想一下撕一块贴在身上一天的狗皮膏药。他的护士选择：快速用力扯，刷的一下。这实在太疼了，尤其对如同木乃伊一般烧伤患者。经过多次痛苦的实践，Dan觉得是时候和医生建议：低疼痛的密度的慢速撕扯 要比刷的一下更能使患者接受。不过他忘记考虑了动作发出者的心里，即病人痛苦的表现给护士本人带来的心理折磨，也是导致护士选择速战速决的原因之一。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>怪诞行为学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Cousera 《Algorithms I》课程作业，对优先队列的应用的几个小问题。 本文参考keyvanakbary,ForeseeMark,zerods-seu的成果 8 puzzle Dynamic Median RandomizedPQ Taxicab 1、8 puzzle类似于华容道，A*算法的应用,对于 Dijstra 来说省略无用的路径，更加高效。 由两个类构成 Board() &amp; Soler()， 相当于以版做单位， 移动之后的状态作为新的 Board，存储于优先队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.util.LinkedList;/** Week 4 - 8 puzzle * Reference: keyvanakbary * Url: https://github.com/keyvanakbary/princeton-algorithms/blob/master/week-4-8-puzzle */public class Board &#123; private static int[][] blocks; public Board(int[][] blocks) &#123; //immutable data type this.blocks = copy(blocks); &#125; private int[][] copy(int[][] blocks) &#123; int[][] copy = new int[blocks.length][blocks.length]; for (int row = 0; row &lt; blocks.length; row++) for (int col = 0; col &lt; blocks.length; col++) copy[row][col] = blocks[row][col]; return copy; &#125; public int dimension() &#123; return blocks.length; &#125; /** * Number of blocks out of place * @return count */ public int hamming() &#123; int count = 0; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) count++; &#125; &#125; return count; &#125; /** * sum of Manhattan distances between blocks and goal * @return sum */ public int manhattan() &#123; int sum = 0; int r, c; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; r = (blocks[row][col] - 1) / dimension(); c = (blocks[row][col] - 1) % dimension(); sum += (Math.abs(row - r) + Math.abs(col - c)); &#125; &#125; return sum; &#125; public boolean isGoal() &#123; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) return false; &#125; &#125; return true; &#125; /** * Judging whether a Board is solvable with a twin Board * @return twin Board */ public Board twin() &#123; int[][] copy = copy(blocks); int rr = 0; if (blocks[rr][0] * blocks[rr][1] == 0) rr = 1; copy[rr][0] = blocks[rr][1]; copy[rr][1] = blocks[rr][0]; return new Board(copy); &#125; public boolean equals(Object that) &#123; // instanceof 指出对象是否是特定类的一个实例 if (this == that) return true; if (that == null || !(that instanceof Board) || ((Board) that).blocks.length != blocks.length) return false; for (int row = 0; row &lt; dimension(); row++) for (int col = 0; col &lt; dimension(); col++) if (((Board) that).blocks[row][col] != blocks[row][col]) return false; return true; &#125; /** * Add the available neighbors to the priority queue * @return an Iterable LinkedList&lt;Board&gt; */ public Iterable&lt;Board&gt; neighbors() &#123; LinkedList&lt;Board&gt; neighbors = new LinkedList&lt;&gt;(); int sR= SpaceLocation()[0]; int sC = SpaceLocation()[1]; if (sR &gt; 0) neighbors.add(new Board(swap(sR, sC, sR - 1, sC))); if (sR &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR + 1, sC))); if (sC &gt; 0) neighbors.add(new Board(swap(sR, sC, sR, sC - 1))); if (sC &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR, sC + 1))); return neighbors; &#125; /** * Swap two blocks * @param r1 row of block1 * @param c1 col of block1 * @param r2 row of block2 * @param c2 col of block2 * @return the swapped array */ private int[][] swap(int r1, int c1, int r2, int c2) &#123; int[][] sblocks = copy(blocks); int tmp = sblocks[r1][c1]; sblocks[r1][c1] = sblocks[r2][c2]; sblocks[r2][c2] = tmp; return sblocks; &#125; /** * @return an array with the location of Space */ private int[] SpaceLocation() &#123; int flag = 0; int[] SL = new int[2]; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) &#123; SL[0] = row; SL[1] = col; flag = 1; break; &#125; &#125; if (flag != 0) break; &#125; return SL; &#125; public String toString() &#123; StringBuilder s = new StringBuilder(); s.append(dimension() + "\n"); for (int i = 0; i &lt; dimension(); i++) &#123; for (int j = 0; j &lt; dimension(); j++) &#123; s.append(String.format("%2d ", blocks[i][j])); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 2、Dynamic Medianjjjoo,找到一组数的中位数 （1）增加一个元素，时间 O(log(n))时间 （2）返回当前元素集合的中位数，O(n)时间。 （3）删除中位数，log(n)时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import edu.princeton.cs.algs4.MaxPQ;import edu.princeton.cs.algs4.MinPQ;/** ******************************************************************************** * Week4: Interview Questions: Priority Queues * Dynamic Median * 使用两个堆维护中位数，这里临界条件"="在MaxPQ上 * judge() 存在边界bug * Reference：1 ForeseeMark https://blog.csdn.net/wr339988/article/details/55813202 * 2 zerods-seu https://blog.csdn.net/zerodshei/article/details/54346425 ***********************************************************************************/public class DynamicMedian &#123; private MinPQ minPQ = new MinPQ(); private MaxPQ maxPQ = new MaxPQ(); public int num = 0; public DynamicMedian() &#123;&#125; public void insert(int n) &#123; if (num == 0) &#123; minPQ.insert(n); num++; return; &#125; if (num == 1) &#123; maxPQ.insert(n); num++; return; &#125; if (n &lt;= (int) maxPQ.max()) maxPQ.insert(n); else minPQ.insert(n); judge(); num++; &#125; public int nums() &#123; return num; &#125; public void delMid() &#123; judge(); maxPQ.delMax(); num--; &#125; /** **************************************************************************** * 2018-09-30 * 判断: 若两个堆的元素个数&gt;1, 则将大堆的顶部元素放入小堆中重排 * 【2】中直接以大堆的顶部元素作为中位数，可能会出现边界情况：[2,3,1] * delMid() 返回 3 ------- BUG * * minPQ maxPQ * 2 3 * 1 * 2018-10-09 update * +立flag 解决边界调节的bug *******************************************************************************/ private void judge() &#123; if (num == 0) throw new NullPointerException(); boolean flag = false; int subVal = maxPQ.size() - minPQ.size(); while (Math.abs(subVal) &gt;= 1) &#123; if (subVal == 1 &amp;&amp; flag) break; if (subVal &lt; -1) maxPQ.insert(minPQ.delMin()); if (subVal == -1) &#123; maxPQ.insert(minPQ.delMin()); flag = true; &#125; if (subVal &gt; 1) minPQ.insert(maxPQ.delMax()); subVal = maxPQ.size() - minPQ.size(); &#125; &#125; public int queryMid() &#123; return (int) maxPQ.max(); &#125; // Test public static void main(String[] args) &#123; DynamicMedian dm = new DynamicMedian(); dm.insert(4); dm.insert(3); dm.insert(5); System.out.println(dm.queryMid()); dm.delMid(); dm.insert(10); dm.insert(2); System.out.println(dm.queryMid()); &#125;&#125; 3、RandomizedPQ具体和课程中给出的优先队列并无二致，加入 delRandom()随机删除一个元素，和删除堆顶元素类似 1234567891011public Key delRandom() &#123; if (isEmpty()) throw new NoSuchElementException("Priority queue underflow"); int rdNum = StdRandom.uniform(1,n); Key rd = pq[rdNum]; exch(rdNum, n--); sink(rdNum); pq[n+1] = null; // to avoid loiterig and help with garbage collection if ((n &gt; 0) &amp;&amp; (n == (pq.length - 1) / 4)) resize(pq.length / 2); assert isMinHeap(); return rd; &#125; 4、TaxicabTaxicab numbers. A taxicab number is an integer that can be expressed as the sum of two cubes of integers in two different ways: a3+b3=c3+d3. For example, 1729=93+103=13+123. Design an algorithm to find all taxicab numbers with a, b, c, and d less than n.Version 1: Use time proportional to n2logn and space proportional to n2.Version 2: Use time proportional to n2logn and space proportional to n. zerods-seu的文章中写到：先计算出所有小于 n1/3 +1 的整数的 3 次方，放在数组 cube[]里面，然后循环，从余下项目中二分法查找(obj-num2), 如果找到了 count++，最后如果 count 等于 2, 那么既满足要求。复杂度是$n4/3logn 的，空间复杂度是 n1/3+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import edu.princeton.cs.algs4.StdOut;import java.util.*;public class Taxicab &#123; public boolean find(int a) &#123; int count = 0; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) count++; if (count &gt; 2) return true; &#125; return false; &#125; public int[] Numb(int a) &#123; int count = 0; int[] nums = new int[4]; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) &#123; count++; if (count == 1) &#123; nums[0] = i; nums[1] = a1; &#125; if (count == 2) &#123; nums[2] = i; nums[3] = a1; &#125; &#125; if (count &gt; 2) return nums; &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; Taxicab tc = new Taxicab(); Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int i = 0, k = 1; while (i &lt; n) &#123; if (tc.find(k)) &#123; i++; System.out.println(i + " th ramanujan number is " + k); System.out.println(tc.Numb(k)[0] + " " + tc.Numb(k)[1] + " &amp; " + tc.Numb(k)[2] + " " + tc.Numb(k)[3]); &#125; k++; &#125; scan.close(); &#125;&#125;]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Capacity of 3D Scale Free Wireless Network]]></title>
    <url>%2F2018%2F09%2F10%2FCapacity-of-3D-Scale-Free-Wireless-Network%2F</url>
    <content type="text"><![CDATA[还记得大四做毕设的时候，看完了20多篇文献。想着这个二维的栅格模型扩展到三维难道不是很容易吗。一个呆在寝室的下午，坐在桌前，面对着一个魔方，想了一会之后豁然开朗。就有了这个 veeery tiny 的小idea。Poster版面也是亲手设计的，这个小文章真的算是亲儿子了。]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counting inversions（逆序对计数问题）]]></title>
    <url>%2F2018%2F07%2F26%2FCounting%20inversions%EF%BC%88%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文参考淡然坊,evasean的 blog 首先想到的是，在插入排序中逆序对的个数就是元素交换的次数。这种特性存在于稳定的排序算法中（归并，冒泡，插入），非稳定的（选择）不适用。 归并中的计算，逆序对的数量由 3 个部分组成：逆序对数量=左半部分的逆序对数量+右半部分的逆序对数量+合并部分的逆序对数量。 令 i 作为左半数组的遍历索引，j 作为右半数组的遍历索引。在合并的任何时刻，一旦发现 a[i] 比 a[j] 大，那么会有 (mid – i + 1) 个逆序对。因为 a[i+1], a[i+2] … a[mid-1] 都比 a[j] 大。 那么最后在 merge 中加入相应的计数即可。]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序对计数</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用泊松过程生成空间点的程序》]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%8A%E7%94%A8%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B%E7%94%9F%E6%88%90%E7%A9%BA%E9%97%B4%E7%82%B9%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本文翻译自利兹大学采矿与矿物工程系《用泊松过程生成空间点的程序》，涉及到齐次泊松过程、非齐次泊松过程和泊松簇过程几章的部分内容，仅供参考。部分公式导入有问题，直接上图。 其中例子多应用于地质分析，对其他分析也有一定帮助。 POSISSON用泊松过程生成空间点的程序利兹大学采矿与矿物工程系 2002年9月 介绍 齐次泊松过程 非齐次泊松过程 泊松簇过程 1、介绍该程序的目的是实现在空间中利用用户定义的泊松过程生成空间点。程序实现的过程类型有：齐次泊松过程，非齐次泊松过程，泊松聚类过程，简单的Cox过程和简单的布尔模型。 实现是在一个矩形区域中构造的A=[x1,x2]*[y1,y2] 其中x1,x2和y1,y2可以被指定。 被划分为方形单元格，每个单元格被视为一个全有界的Borel集合。和中的单元格的数量也可以由程序的用户指定。对于这种安排，所有的细胞是不相交的，因此每个细胞的泊松点的模拟可以独立完成。 要使用的命令全部列在“SpatialPattern”的主菜单下。 选择相应的命令将弹出相关的参数指定窗口。 关闭窗口将激活模拟，一旦过程结束，将显示生成的点。 2、齐次泊松过程 3、非齐次泊松过程 4、泊松簇过程泊松聚类过程为建模具有聚合特征的空间点模式或空间聚类提供了一种工具。 在实践中，它也经常被称为父女建模，或者是层次模型，在这种情况下，父女之间的关系可以有多代，例如Lee和Einstein提到的那一个[3]。泊松聚类过程实际上由两个独立的过程组成，父过程和下一个过程。最后一点的模式通常只由后代（子过程）组成，尽管在某些特殊情况下父过程被包括在内以避免子代大小为0的集群[1]。 泊松聚类过程的实现将具有以下三个特点：父事件是从泊松过程生成的。 该过程可以是均匀密度λ的齐次泊松过程，密度函数λ（X）的非齐次泊松过程，双随机（Cox）泊松过程，或者甚至是另一种情况下的多代亲子模型 正在建设中。 在泊松聚类建模中，这被称为父流程，它为任何后续的子流程奠定了基础，这是以下两个定义的组合。 在这个步骤中获得了N个父母。 许多有趣的泊松聚类过程可以通过最后两个属性的变化来创建。一些已知的过程包括Neyman-Scott聚类过程，该过程用于描述子点独立且分布相同的聚类过程以及Matérn聚类过程，其中父过程是均匀的泊松过程，每个父过程产生产生的后代的泊松数具有相同的分布均值，参见van Lieshout [8]。 对于子过程点位置分布，文献中常见的模式是以母点为中心的半径r内的一个球（3D）或一个圆（二维）内的子点均匀分布，或由给定的PDF 决定。通常假设各向同性分布，即使有一些优先各向异性方向的分布也被提出。 为了生成泊松聚类过程的实现，需要首先生成父过程。 如上所述，父进程可以是同构的或非同类的进程，或者如果对层次结构进行建模，它甚至可以是集群进程本身。 一旦父过程的模型准备好了，就可以继续产生子过程了。图8显示了在实现女儿的程序中实现的选项。 对于每个亲本的后代数量，有三种选择：可以设置为固定数量，可以从指定的均匀分布生成，或者可以从定义的泊松分布生成（因此定义Metérn过程）。 为了将子过程点分配给他们的父过程，实施了两类分配：在椭圆内均匀分布或根据指定的PDF函数分配。对于每个类别，可以指定一个优先分配方向的进一步选项，详细说明见图6和图7。 每个父母的分布椭圆可以固定其轴和主轴方位角，或者这些属性可以根据指定的分布随机地为每个父过程生成。对于裂缝模拟，更可能是后一种情况，因为母体裂缝可能有不同的大小和方位，直接决定了分布椭圆的属性。如果女儿的位置是按照一个已知的模型分配的，那么模型只需要输入到选项3（图8）给出的数据框中。例如，对于径向对称的正常PDF： 图6 传统的父-子过程分配模式 图7 子裂缝位置分布的特殊考虑 图9 当子过程点均匀地分布在以父母为中心的椭圆内（父母是一个密度λ= 10的均匀泊松过程的实现），Poisson簇过程的一些实现。 图10 根据指定的普通PDF模型分配子过程的Poisson簇过程的一些实现（父母是密度λ= 10的均匀泊松过程的一个实现）]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>泊松点过程（PPP）</tag>
        <tag>泊松簇过程（PCP）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
