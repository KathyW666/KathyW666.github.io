<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS3 flex布局]]></title>
    <url>%2F2019%2F05%2F09%2FCSS3-flex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flex 布局是什么？自适应弹性布局 自动判断布局空间，修改自身尺寸 多个 box 在多个方向进行对齐&amp;分布 什么时候用？适用于什么场景？ 布局内部需要自适应 布局内部需要多个方向排列对齐 应用于： 移动端适配，移动端开发 APP 组件，页面栏目 or 小范围板块布局 基础概念 布局结构 双层结构：外层容器flex-container,激活弹性机制。内层flex-item自动获得相关特性。flex-container外部和flex-item内部元素不受影响。 flex 机制 任何一个容器都可以指定为 flex 布局，其内部第一层级的子项自动变为 flex 项目 `display:flex` 块状flex容器 `display:inline-flex`行间flex容器 一旦激活 flex 机制，子项的float、clear 和 vertical-align 属性失效 区域轴向 主轴 &amp; 交叉轴，flex 容器的两端为轴的起点和终点 flex 属性flex-container6 个属性，flex-item6 个属性 外围容器相关属性：对子项的排列和对齐 - flex-direction：定义主轴和交叉轴的方向，文档流入盒子的方向 - flex-wrap：换行 nowrap：往往对应自适应，外围容器固定，item 自动变化 - flex-flow：文档流 flex-direction + flex-wrap 缩写 - justify-content：主轴对齐（左中右，留白环绕，留白中间） - align-items：交叉轴对齐 - align-content：交叉轴多行的对齐方式（容器若只有一行，则无效，避免与align-items发生冲突） 那么问题来了：水平垂直居中的一个方式，就可以用flex布局实现 子项相关属性：子项的自适应伸缩及分配 flex-grow：扩展比例，分配的是剩余的空间（wrap），默认 0 不扩展 flex-shrink：收缩比例（nowrap)，默认 1 等比收缩 flex-basis：定义 item 在主轴上的基本尺寸(定义子项的基本宽 or 高)，默认 auto flex缩写 固定顺序（grow shrink basis）可省略。none auto（可扩展可收缩） 快捷写法：只写 grow shrink，默认忽略设定的width；只写 basis 默认可扩展可收缩。尽量使用 flex 复合写法。 align-self：子项自身的交叉轴对齐方式 order：子项的排列顺序，数值越小越靠前，可以负数 以上两个属于单独调整的两个属性 实例 什么时候想到用 flex - 移动端 - 单、多行垂直居中 - 需要垂直对齐的列表元素 - 单行选项卡 - 垂直弹性布局 - 分栏，一些栏定宽+其他栏自适应 练习 骰子 🎲（练习对齐）👉code 一栏定宽 + 一栏自适应 👉code tab 选项卡 👉code 垂直弹性布局：👉code 另一种方法：header footer position 固定位置注意对 overflow 和 超出视口部分滚动的设置 常见问题 简写 flex 属性，导致设定宽高无效 flex 容器中的文本自动成为 flex 子项，除了空格 子项的 float、clear 和 vertical-align 属性失效 如果子项是绝对定位，定位基准参考 flex 容器的content盒子。因为 flex 本身就是对其 content 的文档流进行操作 flex 子项的 margin：外边距合并失效，margin：auto 可自动分配剩余空间，达到垂直居中的效果，类似操作 flex 容器的主轴交叉轴对齐 flex 容器主轴和 writing-mode：一旦独立设定 writing-mode，优先级高于 flex 容器轴向操作，子项内的文字也会随writing-mode 改变 参考资料阮一峰-flex 布局 zhangwang-flex 属性]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯css实现选项卡]]></title>
    <url>%2F2019%2F04%2F27%2F%E7%BA%AFcss%E5%AE%9E%E7%8E%B0%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[选项卡是个很常见的小组件，总结一下想到的知识点和方法 这里就拿一般意义上的横向选项卡来说，一般来说会结合点击/鼠标移入实现效果的变化，如下拉菜单，背景变化等 布局 float 肯定是可以实现的，absolute+float:left+li，将列表横向布局实现。 如果用这种方法，免不了要想 浮动 可能引发的问题 - 父级高度塌陷。解决的方法也很容易搜到，“古老”方法可以在结构最后添加一个空div清除浮动；“现代”方法用::after伪元素也分分钟解决，注意要设置伪元素为块级元素block才能出现效果，加上clear:both 接下来可能会引申到两端对齐 还可以用inline-block+text-align: justify 实现两端对齐，不过其默认对最后一行无效，新浏览器可配合text-align-last: justify使用。面对兼容问题一样可以使用添加空div或者伪元素，设置display: inline-block，并设置宽度为 100% 另外也可以 flex ，操作更加容易一些 切换 利用 checked 及相关伪类利用input radio的单选特性实现切换，最后清除radio选项的视觉显示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;!-- 纯css实现选项卡切换：利用checkbox及相关伪类 --&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #box &#123; width: 450px; background: whitesmoke; margin: 50px auto; padding: 20px; padding-top: 56px; border-radius: 8px; position: relative; &#125; #box span &#123; position: absolute; width: 150px; text-align: center; height: 36px; line-height: 36px; border-radius: 8px 8px 0 0; background: silver; top: 20px; &#125; #box label:nth-child(1) span&#123; left: 20px; &#125; #box label:nth-child(2) span&#123; left: 170px; &#125; #box label:nth-child(3) span&#123; left: 320px; &#125; #box ul&#123; margin: 0; padding: 0; list-style: none; background: white; padding: 10px; line-height: 26px; display: none; &#125; #box li&#123; height: 26px; overflow: hidden; &#125; #box li:hover&#123; color: orangered; &#125; #box input &#123; display: none; &#125; #box input:checked ~ ul &#123; display: block; &#125; #box input:checked ~ span &#123; background: white; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab1&quot; checked=&quot;checked&quot;/&gt; &lt;span&gt;今日要闻&lt;/span&gt; &lt;ul&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;li&gt;免费游戏如何让玩家们爆肝?日常任务从早到晚都做不完&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab2&quot; /&gt; &lt;span&gt;热门活动&lt;/span&gt; &lt;ul&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;li&gt;《自走棋手游》为了不被国内大厂借鉴 把自己改的面目全非&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab3&quot; /&gt; &lt;span&gt;热点话题&lt;/span&gt; &lt;ul&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;li&gt;邀请玩家一起共创全新NPC角色赢取海量QB&lt;/li&gt; &lt;/ul&gt; &lt;/label&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 利用 锚点实现 herf + :target利用a将href与对应的id绑定，调整显示层级z-index实现切换 要注意利用a的话，点击之后后会自动跳转到 以对应id元素为页面顶端的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; border: 1px black solid; position: relative; &#125; div span&#123; display: flex; &#125; div span&gt;a&#123; flex: 1; text-align: center; line-height: 48px; color: white; background: cornflowerblue; &#125; div ul li&#123; position: absolute; width: 100%; height: 20vw; background: red; left: 0; top: 48px; &#125; div :target&#123; z-index: 55; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;!-- &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; --&gt; &lt;div&gt; &lt;span&gt; &lt;a href=&quot;#tab1&quot;&gt;tab1&lt;/a&gt; &lt;a href=&quot;#tab2&quot;&gt;tab2&lt;/a&gt; &lt;a href=&quot;#tab3&quot;&gt;tab3&lt;/a&gt; &lt;/span&gt; &lt;ul&gt; &lt;li id=&quot;tab1&quot;&gt;tab content1&lt;/li&gt; &lt;li id=&quot;tab2&quot;&gt;tab content2&lt;/li&gt; &lt;li id=&quot;tab3&quot;&gt;tab content3&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt;&lt;!-- &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;h1&gt;title&lt;/h1&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 利用 js直观上想，可以直接利用 js onmouseover onclick 等实现，不过这就不属于纯 css 实现的范畴了]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2019%2F04%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[移动端适配1. 利用百分比实现宽高比固定想实现宽度自适应，高度随宽度变化而变化，宽高比固定。用height百分比显然不行，height百分比是以父元素高度为基准的，而此时需要以宽度为基准来设置高度。 所以这里可以用到padding-top或者padding-bottom，padding是以父元素的width为基准的。我们可以设置元素的height：0，然后用padding-bottom将元素撑开，以实现固定宽高比。 还可以利用vw，vh设置 2. rem以元素字体为基准的单位：默认font-size为16px的话，1rem=16px。可以根据 .clientWidth 读取屏幕宽度，并计算对应的尺寸。 3. 怎样适应视网膜分辨率？ 4. dpr 和 viewportdpr(device pixel ratio)设备像素比viewport 移动端有三: ideal viewport 理想大小，通常设为设备屏宽高 visual viewport 可视大小，整个page在屏幕中显示的大小, 不会超过layout layout viewport 布局大小，page页面的大小 通常页面不会完全显示，因此 visual viewport &lt;= layout viewport, 5. 关于flexible方案 如果 标签中设定了viewport，则取值已设定的 初始dpr 和 ideal viewport 的宽度大小（通常=device-width设备宽度） 若没有, 根据设备设置 dpr 和 缩放倍数（1/dpr）,压缩css像素，保证同等物理大小的范围里，css像素和物理像素比为1. 添加属性及标签 监听页面变化 更新根元素字体大小：这里如果页面宽度低于540px,那么页面中html的font-size也会按照（当前页面宽度/640）的比例变化 initial-dpr 的作用方式是：同时设置 visual viewport 和 layout viewport，如果width属性也有设定，则取二者较大值]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>移动端适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 怪诞行为学 的一些想法]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%85%B3%E4%BA%8E-%E6%80%AA%E8%AF%9E%E8%A1%8C%E4%B8%BA%E5%AD%A6-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018.11.08 update9月份在实验室书架上发现了这本《怪诞行为学》，我自己是对心理学有毫无来由的喜爱，对不正常事件也充满了好奇，估计挺适合找bug的。一开始每天去书架那里看，后来情到深处就拿到自己那里看了，打算看完在放回去。 Dan Ariley 这本书2010年出版的，到现在都快10年了。不过其中的实验和例子非常有趣不乏味。 首先Dan描述了一场飞来横祸使其对行为经济学的兴趣大增的例子。Dan经历过一场镁光灯爆炸，全身70%的皮肤遭受三度烧伤。之后他引出了一个exceptional的问题：怎么撕绷带/膏药/创可贴一类的东西？ Dan恢复时每天要浸在消毒液里(?这里我很疑惑啊，想到了木乃伊)，刮掉坏死的皮肤，再包扎起来。每次换药都会牵扯到尚未完全愈合的伤口，必然非常疼痛。可以设想一下撕一块贴在身上一天的狗皮膏药。他的护士选择：快速用力扯，刷的一下。这实在太疼了，尤其对如同木乃伊一般烧伤患者。经过多次痛苦的实践，Dan觉得是时候和医生建议：低疼痛的密度的慢速撕扯 要比刷的一下更能使患者接受。不过他忘记考虑了动作发出者的心里，即病人痛苦的表现给护士本人带来的心理折磨，也是导致护士选择速战速决的原因之一。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>怪诞行为学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优先队列]]></title>
    <url>%2F2018%2F09%2F28%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本文参考keyvanakbary,ForeseeMark,zerods-seu的成果 8 puzzle Dynamic Median RandomizedPQ Taxicab 1、8 puzzle类似于华容道，A*算法的应用,对于Dijstra来说省略无用的路径，更加高效。 由两个类构成 Board() &amp; Soler()， 相当于以版做单位， 移动之后的状态作为新的Board，存储于优先队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import java.util.LinkedList;/** Week 4 - 8 puzzle * Reference: keyvanakbary * Url: https://github.com/keyvanakbary/princeton-algorithms/blob/master/week-4-8-puzzle */public class Board &#123; private static int[][] blocks; public Board(int[][] blocks) &#123; //immutable data type this.blocks = copy(blocks); &#125; private int[][] copy(int[][] blocks) &#123; int[][] copy = new int[blocks.length][blocks.length]; for (int row = 0; row &lt; blocks.length; row++) for (int col = 0; col &lt; blocks.length; col++) copy[row][col] = blocks[row][col]; return copy; &#125; public int dimension() &#123; return blocks.length; &#125; /** * Number of blocks out of place * @return count */ public int hamming() &#123; int count = 0; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) count++; &#125; &#125; return count; &#125; /** * sum of Manhattan distances between blocks and goal * @return sum */ public int manhattan() &#123; int sum = 0; int r, c; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; r = (blocks[row][col] - 1) / dimension(); c = (blocks[row][col] - 1) % dimension(); sum += (Math.abs(row - r) + Math.abs(col - c)); &#125; &#125; return sum; &#125; public boolean isGoal() &#123; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) continue; if (blocks[row][col] != row * dimension() + col + 1) return false; &#125; &#125; return true; &#125; /** * Judging whether a Board is solvable with a twin Board * @return twin Board */ public Board twin() &#123; int[][] copy = copy(blocks); int rr = 0; if (blocks[rr][0] * blocks[rr][1] == 0) rr = 1; copy[rr][0] = blocks[rr][1]; copy[rr][1] = blocks[rr][0]; return new Board(copy); &#125; public boolean equals(Object that) &#123; // instanceof 指出对象是否是特定类的一个实例 if (this == that) return true; if (that == null || !(that instanceof Board) || ((Board) that).blocks.length != blocks.length) return false; for (int row = 0; row &lt; dimension(); row++) for (int col = 0; col &lt; dimension(); col++) if (((Board) that).blocks[row][col] != blocks[row][col]) return false; return true; &#125; /** * Add the available neighbors to the priority queue * @return an Iterable LinkedList&lt;Board&gt; */ public Iterable&lt;Board&gt; neighbors() &#123; LinkedList&lt;Board&gt; neighbors = new LinkedList&lt;&gt;(); int sR= SpaceLocation()[0]; int sC = SpaceLocation()[1]; if (sR &gt; 0) neighbors.add(new Board(swap(sR, sC, sR - 1, sC))); if (sR &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR + 1, sC))); if (sC &gt; 0) neighbors.add(new Board(swap(sR, sC, sR, sC - 1))); if (sC &lt; dimension() - 1) neighbors.add(new Board(swap(sR, sC, sR, sC + 1))); return neighbors; &#125; /** * Swap two blocks * @param r1 row of block1 * @param c1 col of block1 * @param r2 row of block2 * @param c2 col of block2 * @return the swapped array */ private int[][] swap(int r1, int c1, int r2, int c2) &#123; int[][] sblocks = copy(blocks); int tmp = sblocks[r1][c1]; sblocks[r1][c1] = sblocks[r2][c2]; sblocks[r2][c2] = tmp; return sblocks; &#125; /** * @return an array with the location of Space */ private int[] SpaceLocation() &#123; int flag = 0; int[] SL = new int[2]; for (int row = 0; row &lt; dimension(); row++) &#123; for (int col = 0; col &lt; dimension(); col++) &#123; if (blocks[row][col] == 0) &#123; SL[0] = row; SL[1] = col; flag = 1; break; &#125; &#125; if (flag != 0) break; &#125; return SL; &#125; public String toString() &#123; StringBuilder s = new StringBuilder(); s.append(dimension() + "\n"); for (int i = 0; i &lt; dimension(); i++) &#123; for (int j = 0; j &lt; dimension(); j++) &#123; s.append(String.format("%2d ", blocks[i][j])); &#125; s.append("\n"); &#125; return s.toString(); &#125;&#125; 2、Dynamic Medianjjjoo,找到一组数的中位数 （1）增加一个元素，时间O(log(n))时间 （2）返回当前元素集合的中位数，O(n)时间。 （3）删除中位数，log(n)时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import edu.princeton.cs.algs4.MaxPQ;import edu.princeton.cs.algs4.MinPQ;/** ******************************************************************************** * Week4: Interview Questions: Priority Queues * Dynamic Median * 使用两个堆维护中位数，这里临界条件"="在MaxPQ上 * judge() 存在边界bug * Reference：1 ForeseeMark https://blog.csdn.net/wr339988/article/details/55813202 * 2 zerods-seu https://blog.csdn.net/zerodshei/article/details/54346425 ***********************************************************************************/public class DynamicMedian &#123; private MinPQ minPQ = new MinPQ(); private MaxPQ maxPQ = new MaxPQ(); public int num = 0; public DynamicMedian() &#123;&#125; public void insert(int n) &#123; if (num == 0) &#123; minPQ.insert(n); num++; return; &#125; if (num == 1) &#123; maxPQ.insert(n); num++; return; &#125; if (n &lt;= (int) maxPQ.max()) maxPQ.insert(n); else minPQ.insert(n); judge(); num++; &#125; public int nums() &#123; return num; &#125; public void delMid() &#123; judge(); maxPQ.delMax(); num--; &#125; /** **************************************************************************** * 2018-09-30 * 判断: 若两个堆的元素个数&gt;1, 则将大堆的顶部元素放入小堆中重排 * 【2】中直接以大堆的顶部元素作为中位数，可能会出现边界情况：[2,3,1] * delMid() 返回 3 ------- BUG * * minPQ maxPQ * 2 3 * 1 * 2018-10-09 update * +立flag 解决边界调节的bug *******************************************************************************/ private void judge() &#123; if (num == 0) throw new NullPointerException(); boolean flag = false; int subVal = maxPQ.size() - minPQ.size(); while (Math.abs(subVal) &gt;= 1) &#123; if (subVal == 1 &amp;&amp; flag) break; if (subVal &lt; -1) maxPQ.insert(minPQ.delMin()); if (subVal == -1) &#123; maxPQ.insert(minPQ.delMin()); flag = true; &#125; if (subVal &gt; 1) minPQ.insert(maxPQ.delMax()); subVal = maxPQ.size() - minPQ.size(); &#125; &#125; public int queryMid() &#123; return (int) maxPQ.max(); &#125; // Test public static void main(String[] args) &#123; DynamicMedian dm = new DynamicMedian(); dm.insert(4); dm.insert(3); dm.insert(5); System.out.println(dm.queryMid()); dm.delMid(); dm.insert(10); dm.insert(2); System.out.println(dm.queryMid()); &#125;&#125; 3、RandomizedPQ具体和课程中给出的优先队列并无二致，加入delRandom()随机删除一个元素，和删除堆顶元素类似 1234567891011public Key delRandom() &#123; if (isEmpty()) throw new NoSuchElementException("Priority queue underflow"); int rdNum = StdRandom.uniform(1,n); Key rd = pq[rdNum]; exch(rdNum, n--); sink(rdNum); pq[n+1] = null; // to avoid loiterig and help with garbage collection if ((n &gt; 0) &amp;&amp; (n == (pq.length - 1) / 4)) resize(pq.length / 2); assert isMinHeap(); return rd; &#125; 4、TaxicabTaxicab numbers. A taxicab number is an integer that can be expressed as the sum of two cubes of integers in two different ways: a3+b3=c3+d3. For example, 1729=93+103=13+123. Design an algorithm to find all taxicab numbers with a, b, c, and d less than n.Version 1: Use time proportional to n2logn and space proportional to n2.Version 2: Use time proportional to n2logn and space proportional to n. zerods-seu的文章中写到：先计算出所有小于n1/3 +1的整数的3次方，放在数组cube[]里面，然后循环，从余下项目中二分法查找(obj-num2), 如果找到了count++，最后如果count等于2, 那么既满足要求。复杂度是$n4/3logn的，空间复杂度是n1/3+1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import edu.princeton.cs.algs4.StdOut;import java.util.*;public class Taxicab &#123; public boolean find(int a) &#123; int count = 0; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) count++; if (count &gt; 2) return true; &#125; return false; &#125; public int[] Numb(int a) &#123; int count = 0; int[] nums = new int[4]; int cbrt = (int) Math.cbrt(a); // 小于等于该数字的立方根 for (int i = 1; i &lt;= cbrt; i++) &#123; int diff = a - (i * i * i); int a1 = (int) Math.cbrt(diff); if (a1 == Math.cbrt(diff)) &#123; count++; if (count == 1) &#123; nums[0] = i; nums[1] = a1; &#125; if (count == 2) &#123; nums[2] = i; nums[3] = a1; &#125; &#125; if (count &gt; 2) return nums; &#125; return null; &#125; public static void main(String[] args) throws Exception &#123; Taxicab tc = new Taxicab(); Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int i = 0, k = 1; while (i &lt; n) &#123; if (tc.find(k)) &#123; i++; System.out.println(i + " th ramanujan number is " + k); System.out.println(tc.Numb(k)[0] + " " + tc.Numb(k)[1] + " &amp; " + tc.Numb(k)[2] + " " + tc.Numb(k)[3]); &#125; k++; &#125; scan.close(); &#125;&#125;]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Capacity of 3D Scale Free Wireless Network]]></title>
    <url>%2F2018%2F09%2F10%2FCapacity-of-3D-Scale-Free-Wireless-Network%2F</url>
    <content type="text"><![CDATA[还记得大四做毕设的时候，看完了20多篇文献。想着这个二维的栅格模型扩展到三维难道不是很容易吗。一个呆在寝室的下午，坐在桌前，面对着一个魔方，想了一会之后豁然开朗。就有了这个 veeery tiny 的小idea。Poster版面也是亲手设计的，这个小文章真的算是亲儿子了。]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>复杂网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Counting inversions（逆序对计数问题）]]></title>
    <url>%2F2018%2F07%2F26%2FCounting%20inversions%EF%BC%88%E9%80%86%E5%BA%8F%E5%AF%B9%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文参考淡然坊,evasean的blog 首先想到的是，在插入排序中逆序对的个数就是元素交换的次数。这种特性存在于稳定的排序算法中（归并，冒泡，插入），非稳定的（选择）不适用。 归并中的计算，逆序对的数量由3个部分组成：逆序对数量=左半部分的逆序对数量+右半部分的逆序对数量+合并部分的逆序对数量。 令i作为左半数组的遍历索引，j作为右半数组的遍历索引。在合并的任何时刻，一旦发现a[i] 比 a[j] 大，那么会有 (mid – i + 1) 个逆序对。因为a[i+1], a[i+2] … a[mid-1] 都比a[j] 大。 那么最后在merge中加入相应的计数即可。]]></content>
      <categories>
        <category>普林斯顿算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>逆序对计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用泊松过程生成空间点的程序》]]></title>
    <url>%2F2018%2F07%2F25%2F%E3%80%8A%E7%94%A8%E6%B3%8A%E6%9D%BE%E8%BF%87%E7%A8%8B%E7%94%9F%E6%88%90%E7%A9%BA%E9%97%B4%E7%82%B9%E7%9A%84%E7%A8%8B%E5%BA%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[本文翻译自利兹大学采矿与矿物工程系《用泊松过程生成空间点的程序》，涉及到齐次泊松过程、非齐次泊松过程和泊松簇过程几章的部分内容，仅供参考。部分公式导入有问题，直接上图。 其中例子多应用于地质分析，对其他分析也有一定帮助。 POSISSON用泊松过程生成空间点的程序利兹大学采矿与矿物工程系 2002年9月 介绍 齐次泊松过程 非齐次泊松过程 泊松簇过程 1、介绍该程序的目的是实现在空间中利用用户定义的泊松过程生成空间点。程序实现的过程类型有：齐次泊松过程，非齐次泊松过程，泊松聚类过程，简单的Cox过程和简单的布尔模型。 实现是在一个矩形区域中构造的A=[x1,x2]*[y1,y2] 其中x1,x2和y1,y2可以被指定。 被划分为方形单元格，每个单元格被视为一个全有界的Borel集合。和中的单元格的数量也可以由程序的用户指定。对于这种安排，所有的细胞是不相交的，因此每个细胞的泊松点的模拟可以独立完成。 要使用的命令全部列在“SpatialPattern”的主菜单下。 选择相应的命令将弹出相关的参数指定窗口。 关闭窗口将激活模拟，一旦过程结束，将显示生成的点。 2、齐次泊松过程 3、非齐次泊松过程 4、泊松簇过程泊松聚类过程为建模具有聚合特征的空间点模式或空间聚类提供了一种工具。 在实践中，它也经常被称为父女建模，或者是层次模型，在这种情况下，父女之间的关系可以有多代，例如Lee和Einstein提到的那一个[3]。泊松聚类过程实际上由两个独立的过程组成，父过程和下一个过程。最后一点的模式通常只由后代（子过程）组成，尽管在某些特殊情况下父过程被包括在内以避免子代大小为0的集群[1]。 泊松聚类过程的实现将具有以下三个特点：父事件是从泊松过程生成的。 该过程可以是均匀密度λ的齐次泊松过程，密度函数λ（X）的非齐次泊松过程，双随机（Cox）泊松过程，或者甚至是另一种情况下的多代亲子模型 正在建设中。 在泊松聚类建模中，这被称为父流程，它为任何后续的子流程奠定了基础，这是以下两个定义的组合。 在这个步骤中获得了N个父母。 许多有趣的泊松聚类过程可以通过最后两个属性的变化来创建。一些已知的过程包括Neyman-Scott聚类过程，该过程用于描述子点独立且分布相同的聚类过程以及Matérn聚类过程，其中父过程是均匀的泊松过程，每个父过程产生产生的后代的泊松数具有相同的分布均值，参见van Lieshout [8]。 对于子过程点位置分布，文献中常见的模式是以母点为中心的半径r内的一个球（3D）或一个圆（二维）内的子点均匀分布，或由给定的PDF 决定。通常假设各向同性分布，即使有一些优先各向异性方向的分布也被提出。 为了生成泊松聚类过程的实现，需要首先生成父过程。 如上所述，父进程可以是同构的或非同类的进程，或者如果对层次结构进行建模，它甚至可以是集群进程本身。 一旦父过程的模型准备好了，就可以继续产生子过程了。图8显示了在实现女儿的程序中实现的选项。 对于每个亲本的后代数量，有三种选择：可以设置为固定数量，可以从指定的均匀分布生成，或者可以从定义的泊松分布生成（因此定义Metérn过程）。 为了将子过程点分配给他们的父过程，实施了两类分配：在椭圆内均匀分布或根据指定的PDF函数分配。对于每个类别，可以指定一个优先分配方向的进一步选项，详细说明见图6和图7。 每个父母的分布椭圆可以固定其轴和主轴方位角，或者这些属性可以根据指定的分布随机地为每个父过程生成。对于裂缝模拟，更可能是后一种情况，因为母体裂缝可能有不同的大小和方位，直接决定了分布椭圆的属性。如果女儿的位置是按照一个已知的模型分配的，那么模型只需要输入到选项3（图8）给出的数据框中。例如，对于径向对称的正常PDF： 图6 传统的父-子过程分配模式 图7 子裂缝位置分布的特殊考虑 图9 当子过程点均匀地分布在以父母为中心的椭圆内（父母是一个密度λ= 10的均匀泊松过程的实现），Poisson簇过程的一些实现。 图10 根据指定的普通PDF模型分配子过程的Poisson簇过程的一些实现（父母是密度λ= 10的均匀泊松过程的一个实现）]]></content>
      <categories>
        <category>小硕</category>
      </categories>
      <tags>
        <tag>泊松点过程（PPP）</tag>
        <tag>泊松簇过程（PCP）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[start]]></title>
    <url>%2F2018%2F07%2F22%2Fstart%2F</url>
    <content type="text"><![CDATA[Start Hexo]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
